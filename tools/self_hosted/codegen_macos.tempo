// macOS Code Generation Module - Self-hosted Tempo compiler
module tempo::codegen::macos;

import core;
use core::{malloc, free};
import io;
use io::{print, println};
import tempo::ast;
use tempo::ast::*;

// Target architecture
export enum Architecture {
    X86_64,
    ARM64
}

// Code generator context
export struct CodeGenContext {
    output: ptr<FILE>,
    arch: Architecture,
    current_function: ptr<char>,
    stack_offset: int32,
    label_counter: int32,
    string_literals: ptr<StringLiteral>,
    in_function: bool
}

// String literal tracking
struct StringLiteral {
    label: array<char, 32>,
    value: array<char, 256>,
    next: ptr<StringLiteral>
}

// Create code generation context
@wcet(200)
export function create_codegen_context(arch: Architecture) -> ptr<CodeGenContext> {
    let ctx = malloc(sizeof(CodeGenContext)) as ptr<CodeGenContext>;
    ctx->output = null;
    ctx->arch = arch;
    ctx->current_function = null;
    ctx->stack_offset = 0;
    ctx->label_counter = 0;
    ctx->string_literals = null;
    ctx->in_function = false;
    return ctx;
}

// Generate macOS assembly from AST
@wcet(50000)
export function generate_macos_assembly(
    ast: ptr<ASTNode>, 
    output_file: ptr<char>,
    arch: Architecture
) -> bool {
    let ctx = create_codegen_context(arch);
    
    // TODO: Open output file
    // For now, print to stdout
    
    // Generate header
    generate_header(ctx);
    
    // Generate code
    generate_node(ctx, ast);
    
    // Generate data section
    generate_data_section(ctx);
    
    // Cleanup
    free(ctx as ptr<void>);
    
    return true;
}

// Generate assembly header
@wcet(500)
function generate_header(ctx: ptr<CodeGenContext>) -> void {
    match ctx->arch {
        Architecture::X86_64 => {
            println("# Tempo Compiler - macOS x86-64 Assembly");
            println("# Generated by self-hosted Tempo compiler");
            println("");
            println(".section __TEXT,__text");
            println(".globl _main");
            println(".p2align 4, 0x90");
            println("");
        },
        Architecture::ARM64 => {
            println("// Tempo Compiler - macOS ARM64 Assembly");
            println("// Generated by self-hosted Tempo compiler");
            println("");
            println(".section __TEXT,__text");
            println(".globl _main");
            println(".p2align 2");
            println("");
        }
    }
}

// Generate code for AST node
@wcet(20000)
function generate_node(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    if node == null {
        return;
    }
    
    match node->type {
        ASTNodeType::AST_PROGRAM => {
            match node->data {
                ASTNodeData::Program { declarations, ... } => {
                    generate_node(ctx, declarations);
                },
                _ => {}
            }
        },
        ASTNodeType::AST_FUNCTION => {
            generate_function(ctx, node);
        },
        ASTNodeType::AST_BLOCK => {
            generate_block(ctx, node);
        },
        ASTNodeType::AST_RETURN => {
            generate_return(ctx, node);
        },
        ASTNodeType::AST_VARIABLE => {
            generate_variable_decl(ctx, node);
        },
        ASTNodeType::AST_BINARY_OP => {
            generate_binary_op(ctx, node);
        },
        ASTNodeType::AST_CALL => {
            generate_call(ctx, node);
        },
        ASTNodeType::AST_INTEGER_LITERAL => {
            generate_integer_literal(ctx, node);
        },
        ASTNodeType::AST_STRING_LITERAL => {
            generate_string_literal(ctx, node);
        },
        ASTNodeType::AST_IDENTIFIER => {
            generate_identifier(ctx, node);
        },
        _ => {
            // TODO: Handle other node types
        }
    }
    
    // Process siblings
    if node->next != null {
        generate_node(ctx, node->next);
    }
}

// Generate function code
@wcet(5000)
function generate_function(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::Function { name, params, return_type, body, is_export, ... } => {
            ctx->in_function = true;
            ctx->current_function = name as ptr<char>;
            ctx->stack_offset = 0;
            
            // Function label
            if str_equals(name as ptr<char>, "main") {
                println("_main:");
            } else {
                print("_");
                print(name as ptr<char>);
                println(":");
            }
            
            // Function prologue
            match ctx->arch {
                Architecture::X86_64 => {
                    println("    pushq %rbp");
                    println("    movq %rsp, %rbp");
                    
                    // Reserve stack space for locals
                    // TODO: Calculate actual space needed
                    println("    subq $32, %rsp");
                },
                Architecture::ARM64 => {
                    println("    stp x29, x30, [sp, #-16]!");
                    println("    mov x29, sp");
                    
                    // Reserve stack space for locals
                    println("    sub sp, sp, #32");
                }
            }
            
            // Generate function body
            generate_node(ctx, body);
            
            // Function epilogue (if no explicit return)
            match ctx->arch {
                Architecture::X86_64 => {
                    println("    xorl %eax, %eax");  // Default return 0
                    println("    leave");
                    println("    ret");
                },
                Architecture::ARM64 => {
                    println("    mov w0, #0");  // Default return 0
                    println("    ldp x29, x30, [sp], #16");
                    println("    ret");
                }
            }
            
            println("");
            ctx->in_function = false;
        },
        _ => {}
    }
}

// Generate block statement
@wcet(1000)
function generate_block(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::Block { statements } => {
            generate_node(ctx, statements);
        },
        _ => {}
    }
}

// Generate return statement
@wcet(1000)
function generate_return(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::Return { expr } => {
            if expr != null {
                generate_node(ctx, expr);
                // Result is in accumulator register
            }
            
            match ctx->arch {
                Architecture::X86_64 => {
                    println("    leave");
                    println("    ret");
                },
                Architecture::ARM64 => {
                    println("    ldp x29, x30, [sp], #16");
                    println("    ret");
                }
            }
        },
        _ => {}
    }
}

// Generate binary operation
@wcet(2000)
function generate_binary_op(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::BinaryOp { op, left, right } => {
            // Generate left operand
            generate_node(ctx, left);
            
            // Save result
            match ctx->arch {
                Architecture::X86_64 => {
                    println("    pushq %rax");
                },
                Architecture::ARM64 => {
                    println("    str w0, [sp, #-16]!");
                }
            }
            
            // Generate right operand
            generate_node(ctx, right);
            
            // Perform operation
            match ctx->arch {
                Architecture::X86_64 => {
                    println("    popq %rcx");
                    match op {
                        BinaryOp::OP_ADD => println("    addl %ecx, %eax"),
                        BinaryOp::OP_SUB => {
                            println("    movl %ecx, %edx");
                            println("    subl %eax, %edx");
                            println("    movl %edx, %eax");
                        },
                        BinaryOp::OP_MUL => println("    imull %ecx, %eax"),
                        BinaryOp::OP_DIV => {
                            println("    movl %eax, %ecx");
                            println("    movl %edx, %eax");
                            println("    cltd");
                            println("    idivl %ecx");
                        },
                        _ => {}
                    }
                },
                Architecture::ARM64 => {
                    println("    ldr w1, [sp], #16");
                    match op {
                        BinaryOp::OP_ADD => println("    add w0, w1, w0"),
                        BinaryOp::OP_SUB => println("    sub w0, w1, w0"),
                        BinaryOp::OP_MUL => println("    mul w0, w1, w0"),
                        BinaryOp::OP_DIV => println("    sdiv w0, w1, w0"),
                        _ => {}
                    }
                }
            }
        },
        _ => {}
    }
}

// Generate function call
@wcet(3000)
function generate_call(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::Call { func, args } => {
            // Generate arguments (right to left for x86-64)
            let arg_count = 0;
            let arg = args;
            while arg != null {
                arg_count = arg_count + 1;
                arg = arg->next;
            }
            
            // Generate arguments
            match ctx->arch {
                Architecture::X86_64 => {
                    // First 6 args in registers: rdi, rsi, rdx, rcx, r8, r9
                    // Rest on stack
                    let arg_num = 0;
                    arg = args;
                    while arg != null {
                        generate_node(ctx, arg);
                        
                        if arg_num == 0 {
                            println("    movl %eax, %edi");
                        } else if arg_num == 1 {
                            println("    movl %eax, %esi");
                        } else if arg_num == 2 {
                            println("    movl %eax, %edx");
                        } else if arg_num == 3 {
                            println("    movl %eax, %ecx");
                        } else if arg_num == 4 {
                            println("    movl %eax, %r8d");
                        } else if arg_num == 5 {
                            println("    movl %eax, %r9d");
                        } else {
                            println("    pushq %rax");
                        }
                        
                        arg_num = arg_num + 1;
                        arg = arg->next;
                    }
                },
                Architecture::ARM64 => {
                    // First 8 args in registers: x0-x7
                    // Rest on stack
                    let arg_num = 0;
                    arg = args;
                    while arg != null {
                        generate_node(ctx, arg);
                        
                        if arg_num < 8 {
                            print("    mov w");
                            print_int(arg_num);
                            println(", w0");
                        } else {
                            println("    str w0, [sp, #-16]!");
                        }
                        
                        arg_num = arg_num + 1;
                        arg = arg->next;
                    }
                }
            }
            
            // Call function
            match node->data {
                ASTNodeData::Call { func, ... } => {
                    match func->data {
                        ASTNodeData::Identifier { name } => {
                            match ctx->arch {
                                Architecture::X86_64 => {
                                    print("    call _");
                                    println(name as ptr<char>);
                                },
                                Architecture::ARM64 => {
                                    print("    bl _");
                                    println(name as ptr<char>);
                                }
                            }
                        },
                        _ => {}
                    }
                },
                _ => {}
            }
            
            // Clean up stack if needed
            if arg_count > 6 && ctx->arch == Architecture::X86_64 {
                print("    addq $");
                print_int((arg_count - 6) * 8);
                println(", %rsp");
            }
        },
        _ => {}
    }
}

// Generate integer literal
@wcet(500)
function generate_integer_literal(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::IntegerLiteral { value } => {
            match ctx->arch {
                Architecture::X86_64 => {
                    print("    movl $");
                    print_int(value as int32);
                    println(", %eax");
                },
                Architecture::ARM64 => {
                    print("    mov w0, #");
                    print_int(value as int32);
                    println("");
                }
            }
        },
        _ => {}
    }
}

// Generate string literal
@wcet(1000)
function generate_string_literal(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::StringLiteral { value } => {
            // Add to string literal list
            let str_lit = malloc(sizeof(StringLiteral)) as ptr<StringLiteral>;
            
            // Generate label
            let label_prefix = "L_.str.";
            let i = 0;
            while label_prefix[i] != 0 {
                str_lit->label[i] = label_prefix[i];
                i = i + 1;
            }
            // Add counter
            let counter = ctx->label_counter;
            ctx->label_counter = ctx->label_counter + 1;
            // Simple conversion (works for small numbers)
            if counter < 10 {
                str_lit->label[i] = '0' + counter as char;
                i = i + 1;
            }
            str_lit->label[i] = 0;
            
            // Copy value
            i = 0;
            while value[i] != 0 && i < 255 {
                str_lit->value[i] = value[i];
                i = i + 1;
            }
            str_lit->value[i] = 0;
            
            // Add to list
            str_lit->next = ctx->string_literals;
            ctx->string_literals = str_lit;
            
            // Generate reference
            match ctx->arch {
                Architecture::X86_64 => {
                    print("    leaq ");
                    print(str_lit->label as ptr<char>);
                    println("(%rip), %rax");
                },
                Architecture::ARM64 => {
                    print("    adrp x0, ");
                    print(str_lit->label as ptr<char>);
                    println("@PAGE");
                    print("    add x0, x0, ");
                    print(str_lit->label as ptr<char>);
                    println("@PAGEOFF");
                }
            }
        },
        _ => {}
    }
}

// Generate identifier reference
@wcet(1000)
function generate_identifier(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::Identifier { name } => {
            // TODO: Look up variable location
            // For now, assume local variable on stack
            match ctx->arch {
                Architecture::X86_64 => {
                    println("    movl -4(%rbp), %eax");  // Placeholder
                },
                Architecture::ARM64 => {
                    println("    ldr w0, [x29, #-4]");  // Placeholder
                }
            }
        },
        _ => {}
    }
}

// Generate variable declaration
@wcet(1500)
function generate_variable_decl(ctx: ptr<CodeGenContext>, node: ptr<ASTNode>) -> void {
    match node->data {
        ASTNodeData::Variable { name, init_expr, ... } => {
            if init_expr != null {
                // Generate initialization expression
                generate_node(ctx, init_expr);
                
                // Store in local variable
                ctx->stack_offset = ctx->stack_offset + 4;
                match ctx->arch {
                    Architecture::X86_64 => {
                        print("    movl %eax, -");
                        print_int(ctx->stack_offset);
                        println("(%rbp)");
                    },
                    Architecture::ARM64 => {
                        print("    str w0, [x29, #-");
                        print_int(ctx->stack_offset);
                        println("]");
                    }
                }
            }
        },
        _ => {}
    }
}

// Generate data section
@wcet(2000)
function generate_data_section(ctx: ptr<CodeGenContext>) -> void {
    if ctx->string_literals == null {
        return;
    }
    
    println("");
    println(".section __TEXT,__cstring");
    
    let str_lit = ctx->string_literals;
    while str_lit != null {
        print(str_lit->label as ptr<char>);
        println(":");
        print("    .asciz \"");
        print(str_lit->value as ptr<char>);
        println("\"");
        str_lit = str_lit->next;
    }
}

// Platform-specific runtime functions
@wcet(5000)
export function generate_runtime_functions(ctx: ptr<CodeGenContext>) -> void {
    println("");
    println("# Runtime functions");
    println("");
    
    // Print function for integers
    match ctx->arch {
        Architecture::X86_64 => {
            println("_print_int:");
            println("    pushq %rbp");
            println("    movq %rsp, %rbp");
            println("    # Convert integer to string and print");
            println("    # TODO: Implement");
            println("    leave");
            println("    ret");
        },
        Architecture::ARM64 => {
            println("_print_int:");
            println("    stp x29, x30, [sp, #-16]!");
            println("    mov x29, sp");
            println("    // Convert integer to string and print");
            println("    // TODO: Implement");
            println("    ldp x29, x30, [sp], #16");
            println("    ret");
        }
    }
    
    println("");
    
    // System call wrappers
    generate_syscall_wrappers(ctx);
}

// Generate system call wrappers for macOS
@wcet(3000)
function generate_syscall_wrappers(ctx: ptr<CodeGenContext>) -> void {
    match ctx->arch {
        Architecture::X86_64 => {
            // Exit syscall
            println("_sys_exit:");
            println("    movl $0x2000001, %eax");  // macOS exit syscall
            println("    syscall");
            println("    ret");
            println("");
            
            // Write syscall
            println("_sys_write:");
            println("    movl $0x2000004, %eax");  // macOS write syscall
            println("    syscall");
            println("    ret");
        },
        Architecture::ARM64 => {
            // Exit syscall
            println("_sys_exit:");
            println("    mov x16, #1");  // exit syscall number
            println("    svc #0x80");    // macOS system call
            println("    ret");
            println("");
            
            // Write syscall
            println("_sys_write:");
            println("    mov x16, #4");  // write syscall number
            println("    svc #0x80");
            println("    ret");
        }
    }
}

// Helper: String comparison
@wcet(200)
function str_equals(s1: ptr<char>, s2: ptr<char>) -> bool {
    let i = 0;
    while s1[i] != 0 && s2[i] != 0 {
        if s1[i] != s2[i] {
            return false;
        }
        i = i + 1;
    }
    return s1[i] == s2[i];
}

// Helper: Print integer
@wcet(300)
function print_int(value: int32) -> void {
    if value == 0 {
        print("0");
        return;
    }
    
    let buffer: array<char, 12>;
    let i = 0;
    let negative = false;
    
    if value < 0 {
        negative = true;
        value = -value;
    }
    
    // Convert to string (reversed)
    while value > 0 {
        buffer[i] = '0' + (value % 10) as char;
        value = value / 10;
        i = i + 1;
    }
    
    if negative {
        print("-");
    }
    
    // Print digits in correct order
    while i > 0 {
        i = i - 1;
        let ch: array<char, 2> = [buffer[i], 0];
        print(ch as ptr<char>);
    }
}
// Main compiler driver - Self-hosted Tempo compiler
module tempo::compiler;

import core;
use core::{malloc, free};
import io;
use io::{print, println, print_int};
import tempo::lexer;
use tempo::lexer::{lexer_new};
import tempo::parser;
use tempo::parser::{parser_new, parse_program};
import tempo::ast;
use tempo::ast::{print_ast, free_ast};
import tempo::codegen::macos;
use tempo::codegen::macos::{Architecture, generate_macos_assembly};

// Compiler options
export struct CompilerOptions {
    input_file: array<char, 256>,
    output_file: array<char, 256>,
    optimize: bool,
    debug: bool,
    emit_llvm: bool,
    emit_asm: bool,
    target_triple: array<char, 256>,
    wcet_analysis: bool,
    security_level: int32
}

// Compiler context
export struct CompilerContext {
    options: ptr<CompilerOptions>,
    source_code: ptr<char>,
    source_length: int32,
    errors: int32,
    warnings: int32
}

// Create compiler context
@wcet(200)
export function create_compiler_context() -> ptr<CompilerContext> {
    let ctx = malloc(sizeof(CompilerContext)) as ptr<CompilerContext>;
    ctx->options = null;
    ctx->source_code = null;
    ctx->source_length = 0;
    ctx->errors = 0;
    ctx->warnings = 0;
    return ctx;
}

// Read source file
@wcet(5000)
function read_source_file(filename: ptr<char>) -> ptr<char> {
    // TODO: Implement file reading
    // For now, return a test program
    let test_program = "
module test;

import io;

@wcet(50)
function fibonacci(n: int32) -> int32 {
    if n <= 1 {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

@wcet(200)
export function main() -> int32 {
    let result = fibonacci(10);
    io::print(\"Fibonacci(10) = \");
    io::print_int(result);
    io::println(\"\");
    return 0;
}
";
    
    // Calculate length
    let len = 0;
    while test_program[len] != 0 {
        len = len + 1;
    }
    
    // Allocate and copy
    let buffer = malloc(len + 1) as ptr<char>;
    for let i = 0; i <= len; i = i + 1 {
        buffer[i] = test_program[i];
    }
    
    return buffer;
}

// Compile source code
@wcet(50000)
export function compile(ctx: ptr<CompilerContext>) -> bool {
    println("=== Tempo Self-Hosted Compiler v1.0.0 ===");
    println("");
    
    // Phase 1: Lexical Analysis
    print("Phase 1: Lexical analysis... ");
    let lexer = lexer_new(ctx->source_code, ctx->source_length);
    println("done");
    
    // Phase 2: Parsing
    print("Phase 2: Parsing... ");
    let parser = parser_new(lexer);
    let ast = parse_program(parser);
    
    if parser->error_count > 0 {
        println("failed");
        print("  ");
        print_int(parser->error_count);
        println(" parse errors found");
        ctx->errors = parser->error_count;
        
        // Print errors
        let error = parser->errors;
        while error != null {
            print("  Error at ");
            print_int(error->line);
            print(":");
            print_int(error->column);
            print(" - ");
            println(error->message as ptr<char>);
            error = error->next;
        }
        
        free_ast(ast);
        free(parser as ptr<void>);
        free(lexer as ptr<void>);
        return false;
    }
    println("done");
    
    // Phase 3: Semantic Analysis
    print("Phase 3: Semantic analysis... ");
    // TODO: Implement type checking
    println("done");
    
    // Phase 4: WCET Analysis
    if ctx->options->wcet_analysis {
        print("Phase 4: WCET analysis... ");
        // TODO: Implement WCET analysis
        println("done");
    }
    
    // Phase 5: Optimization
    if ctx->options->optimize {
        print("Phase 5: Optimization... ");
        // TODO: Implement optimizations
        println("done");
    }
    
    // Phase 6: Code Generation
    print("Phase 6: Code generation... ");
    if ctx->options->emit_llvm {
        // TODO: Generate LLVM IR
        println("LLVM IR generation not yet implemented");
    } else {
        // Generate assembly
        generate_assembly(ast, ctx->options->output_file);
        println("done");
    }
    
    // Cleanup
    free_ast(ast);
    free(parser as ptr<void>);
    free(lexer as ptr<void>);
    
    println("");
    println("Compilation successful!");
    print("  Errors: ");
    print_int(ctx->errors);
    print(", Warnings: ");
    print_int(ctx->warnings);
    println("");
    
    return ctx->errors == 0;
}

// Generate assembly code
@wcet(20000)
function generate_assembly(ast: ptr<ASTNode>, output_file: ptr<char>) -> void {
    // Detect architecture
    let arch = detect_architecture();
    
    // Use macOS code generator
    generate_macos_assembly(ast, output_file, arch);
}

// Detect system architecture
@wcet(100)
function detect_architecture() -> Architecture {
    // TODO: Actually detect architecture
    // For now, assume x86_64 on Intel Macs, ARM64 on Apple Silicon
    #if defined(__x86_64__)
        return Architecture::X86_64;
    #else
        return Architecture::ARM64;
    #endif
}

// Generate functions from AST
@wcet(10000)
function generate_functions(node: ptr<ASTNode>) -> void {
    if node == null {
        return;
    }
    
    match node->type {
        ASTNodeType::AST_PROGRAM => {
            match node->data {
                ASTNodeData::Program { declarations, ... } => {
                    generate_functions(declarations);
                },
                _ => {}
            }
        },
        ASTNodeType::AST_FUNCTION => {
            match node->data {
                ASTNodeData::Function { name, params, return_type, body, ... } => {
                    print(name as ptr<char>);
                    println(":");
                    println("    pushl %ebp");
                    println("    movl %esp, %ebp");
                    println("    # Function body");
                    println("    # TODO: Generate code from body AST");
                    println("    leave");
                    println("    ret");
                    println("");
                },
                _ => {}
            }
        },
        _ => {}
    }
    
    // Process siblings
    if node->next != null {
        generate_functions(node->next);
    }
}

// Parse command line arguments
@wcet(1000)
export function parse_args(argc: int32, argv: ptr<ptr<char>>) -> ptr<CompilerOptions> {
    let options = malloc(sizeof(CompilerOptions)) as ptr<CompilerOptions>;
    
    // Initialize with defaults
    options->optimize = false;
    options->debug = false;
    options->emit_llvm = false;
    options->emit_asm = true;
    options->wcet_analysis = true;
    options->security_level = 2;
    
    // Set default target triple
    let default_target = "i386-atomicos-elf";
    let i = 0;
    while default_target[i] != 0 && i < 255 {
        options->target_triple[i] = default_target[i];
        i = i + 1;
    }
    options->target_triple[i] = 0;
    
    // Parse arguments
    if argc < 2 {
        println("Usage: tempo <input.tempo> [-o output] [options]");
        return null;
    }
    
    // Copy input filename
    i = 0;
    while argv[1][i] != 0 && i < 255 {
        options->input_file[i] = argv[1][i];
        i = i + 1;
    }
    options->input_file[i] = 0;
    
    // Generate default output filename
    i = 0;
    while options->input_file[i] != 0 && options->input_file[i] != '.' && i < 250 {
        options->output_file[i] = options->input_file[i];
        i = i + 1;
    }
    options->output_file[i] = '.';
    options->output_file[i+1] = 's';
    options->output_file[i+2] = 0;
    
    // Parse remaining arguments
    for let arg = 2; arg < argc; arg = arg + 1 {
        if str_equals(argv[arg], "-o") && arg + 1 < argc {
            // Output file
            arg = arg + 1;
            i = 0;
            while argv[arg][i] != 0 && i < 255 {
                options->output_file[i] = argv[arg][i];
                i = i + 1;
            }
            options->output_file[i] = 0;
        } else if str_equals(argv[arg], "-O") {
            options->optimize = true;
        } else if str_equals(argv[arg], "-g") {
            options->debug = true;
        } else if str_equals(argv[arg], "--emit-llvm") {
            options->emit_llvm = true;
            options->emit_asm = false;
        } else if str_equals(argv[arg], "--no-wcet") {
            options->wcet_analysis = false;
        }
    }
    
    return options;
}

// String comparison helper
@wcet(200)
function str_equals(s1: ptr<char>, s2: ptr<char>) -> bool {
    let i = 0;
    while s1[i] != 0 && s2[i] != 0 {
        if s1[i] != s2[i] {
            return false;
        }
        i = i + 1;
    }
    return s1[i] == s2[i];
}

// Main entry point
@wcet(100000)
export function main(argc: int32, argv: ptr<ptr<char>>) -> int32 {
    // Parse command line arguments
    let options = parse_args(argc, argv);
    if options == null {
        return 1;
    }
    
    // Create compiler context
    let ctx = create_compiler_context();
    ctx->options = options;
    
    // Read source file
    print("Reading ");
    print(options->input_file as ptr<char>);
    print("... ");
    ctx->source_code = read_source_file(options->input_file as ptr<char>);
    if ctx->source_code == null {
        println("failed");
        return 1;
    }
    
    // Calculate source length
    ctx->source_length = 0;
    while ctx->source_code[ctx->source_length] != 0 {
        ctx->source_length = ctx->source_length + 1;
    }
    println("done");
    
    // Compile
    let success = compile(ctx);
    
    // Cleanup
    free(ctx->source_code as ptr<void>);
    free(options as ptr<void>);
    free(ctx as ptr<void>);
    
    return if success { 0 } else { 1 };
}

// Test the compiler
@wcet(50000)
export function test_compiler() -> void {
    println("=== Testing Self-Hosted Tempo Compiler ===");
    println("");
    
    // Create test context
    let ctx = create_compiler_context();
    
    // Create test options
    let options = malloc(sizeof(CompilerOptions)) as ptr<CompilerOptions>;
    options->optimize = true;
    options->debug = false;
    options->emit_llvm = false;
    options->emit_asm = true;
    options->wcet_analysis = true;
    options->security_level = 2;
    
    let input = "test.tempo";
    let output = "test.s";
    let i = 0;
    while input[i] != 0 {
        options->input_file[i] = input[i];
        i = i + 1;
    }
    options->input_file[i] = 0;
    
    i = 0;
    while output[i] != 0 {
        options->output_file[i] = output[i];
        i = i + 1;
    }
    options->output_file[i] = 0;
    
    ctx->options = options;
    
    // Test program
    ctx->source_code = "
module test;

import io;

function factorial(n: int32) -> int32 {
    if n <= 1 {
        return 1;
    }
    return n * factorial(n - 1);
}

function main() -> int32 {
    let result = factorial(5);
    io::print_int(result);
    return 0;
}
";
    
    // Calculate length
    ctx->source_length = 0;
    while ctx->source_code[ctx->source_length] != 0 {
        ctx->source_length = ctx->source_length + 1;
    }
    
    // Compile
    compile(ctx);
    
    // Cleanup
    free(options as ptr<void>);
    free(ctx as ptr<void>);
}
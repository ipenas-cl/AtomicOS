; Copyright (c) 2024 Ignacio Pe√±a
; Part of AtomicOS Project - https://github.com/ipenas-cl/AtomicOS
; Licensed under MIT License - see LICENSE file for details

; AtomicOS Working Shell with Stack-Smashing Protection and Interrupts
[BITS 32]
[ORG 0x10000]

%define VGA_BUFFER 0xB8000

section .text
global _start

; SSP functions generated by Tempo
global STACK_CANARY
global CANARY_DEAD  
global ssp_init_canary
global ssp_set_canary
global ssp_check_canary
global ssp_handle_corruption
global ssp_function_enter
global ssp_function_exit

; Guard Pages functions generated by Tempo
global PAGE_SIZE
global GUARD_MARKER
global install_guard_page
global check_guard_violation
global handle_guard_violation
global guard_pages_init
global safe_memory_access

; Deterministic Core functions
global MEMORY_POOL_SIZE
global MEMORY_BLOCK_SIZE
global static_memory_init
global static_alloc_block
global DETERMINISTIC_SEED
global deterministic_random
global RT_PRIORITY_HIGH
global RT_PRIORITY_NORMAL
global RT_PRIORITY_LOW
global rt_task_create
global SECURITY_LEVEL_KERNEL
global SECURITY_LEVEL_SYSTEM
global SECURITY_LEVEL_USER
global SECURITY_LEVEL_GUEST
global security_check_access
global ERROR_NONE
global ERROR_INVALID_PARAM
global ERROR_OUT_OF_BOUNDS
global ERROR_TIMEOUT
global ERROR_SECURITY_VIOLATION
global deterministic_system_init

; Include Tempo-generated security and deterministic code
%include "kernel/ssp_functions.inc"
%include "kernel/guard_pages.inc"
%include "kernel/deterministic_core.inc"
%include "kernel/interrupts.inc"
%include "kernel/logo.inc"
%include "kernel/context_switch.inc"
%include "kernel/process_management.inc"
%include "kernel/realtime_scheduler.inc"
%include "kernel/syscall_handler.inc"
%include "kernel/ipc_stubs.inc"
%include "kernel/fs_stubs.inc"
%include "kernel/paging.inc"

_start:
    ; Initialize Deterministic Core System
    call deterministic_system_init
    test eax, eax
    jnz .security_init_failed
    
    ; Initialize Guard Pages system
    call guard_pages_init
    test eax, eax
    jz .security_init_failed
    
    ; Initialize SSP protection for main function
    push esp                ; Pass current stack pointer
    call ssp_function_enter
    add esp, 4
    push eax               ; Save canary address for later exit
    
    ; Initialize interrupt system
    call init_idt          ; Set up IDT with all handlers
    call load_idt          ; Load the IDT
    call init_timer        ; Initialize timer for scheduling
    
    ; Initialize paging (must be before process management)
    call init_paging
    
    ; Initialize process management
    call init_process_management
    
    ; Initialize real-time scheduler
    call init_rt_scheduler
    
    ; Initialize system call interface
    call init_syscall_handler
    
    ; Create a test process
    push 0              ; Priority NORMAL
    push test_process   ; Entry point
    push test_proc_name ; Name
    call create_process
    add esp, 12
    
    ; Create a real-time task example
    push 0              ; No specific deadline (use period)
    push test_rt_task   ; Entry point
    push 100           ; WCET: 100 microseconds
    push 1000          ; Period: 1000 microseconds (1ms)
    call rt_create_task
    add esp, 16
    
    ; Quick system validation tests
    call validate_systems
    
    call enable_interrupts ; Enable interrupts (STI)
    
    ; Clear screen exactly like debug test
    mov edi, VGA_BUFFER
    mov ecx, 80 * 25
    mov ax, 0x0720    ; Space with white on black
    
.clear:
    mov [edi], ax
    add edi, 2
    loop .clear
    
    ; Display AtomicOS logo
    mov edi, VGA_BUFFER + (5 * 80 * 2)  ; Start at line 5
    mov esi, atomicos_logo
    mov ebx, logo_lines
    
.logo_loop:
    push edi
    push esi
    
    ; Center the logo (each line is 50 chars, center in 80 cols)
    add edi, 15 * 2  ; Move 15 chars to the right
    
.logo_line:
    lodsb
    test al, al
    jz .next_logo_line
    mov [edi], al
    mov byte [edi+1], 0x0B  ; Cyan on black
    add edi, 2
    jmp .logo_line
    
.next_logo_line:
    pop esi
    pop edi
    
    ; Skip to next string
.find_next:
    lodsb
    test al, al
    jnz .find_next
    
    add edi, 160  ; Next line
    dec ebx
    jnz .logo_loop
    
    ; Write welcome message - AtomicOS Deterministic
    mov edi, VGA_BUFFER
    mov esi, welcome_msg
    mov ecx, welcome_len
    mov ah, 0x0A          ; Green on black
    
.write_welcome:
    lodsb
    mov [edi], al
    mov [edi+1], ah
    add edi, 2
    loop .write_welcome
    
    ; Write prompt on second line
    mov edi, VGA_BUFFER + 160  ; Second line
    mov byte [edi], '$'
    mov byte [edi+1], 0x0A     ; Green
    mov byte [edi+2], ' '
    mov byte [edi+3], 0x0A
    
    ; Set cursor position for input
    mov edi, VGA_BUFFER + 164  ; After prompt
    mov ecx, 0                 ; Character count
    
.key_loop:
    ; Wait for key
    in al, 0x64
    test al, 1
    jz .key_loop
    
    ; Read scancode
    in al, 0x60
    
    ; Ignore releases
    test al, 0x80
    jnz .key_loop
    
    ; Check Enter (scancode 0x1C)
    cmp al, 0x1C
    je .process_enter
    
    ; Check Backspace (scancode 0x0E)
    cmp al, 0x0E
    je .process_backspace
    
    ; Convert common scancodes to ASCII
    mov bl, 0
    cmp al, 0x1E    ; A
    jne .not_a
    mov bl, 'a'
    jmp .show_char
.not_a:
    cmp al, 0x30    ; B
    jne .not_b
    mov bl, 'b'
    jmp .show_char
.not_b:
    cmp al, 0x2E    ; C
    jne .not_c
    mov bl, 'c'
    jmp .show_char
.not_c:
    cmp al, 0x20    ; D
    jne .not_d
    mov bl, 'd'
    jmp .show_char
.not_d:
    cmp al, 0x12    ; E
    jne .not_e
    mov bl, 'e'
    jmp .show_char
.not_e:
    cmp al, 0x21    ; F
    jne .not_f
    mov bl, 'f'
    jmp .show_char
.not_f:
    cmp al, 0x22    ; G
    jne .not_g
    mov bl, 'g'
    jmp .show_char
.not_g:
    cmp al, 0x23    ; H
    jne .not_h
    mov bl, 'h'
    jmp .show_char
.not_h:
    cmp al, 0x17    ; I
    jne .not_i
    mov bl, 'i'
    jmp .show_char
.not_i:
    cmp al, 0x24    ; J
    jne .not_j
    mov bl, 'j'
    jmp .show_char
.not_j:
    cmp al, 0x25    ; K
    jne .not_k
    mov bl, 'k'
    jmp .show_char
.not_k:
    cmp al, 0x26    ; L
    jne .not_l
    mov bl, 'l'
    jmp .show_char
.not_l:
    cmp al, 0x32    ; M
    jne .not_m
    mov bl, 'm'
    jmp .show_char
.not_m:
    cmp al, 0x31    ; N
    jne .not_n
    mov bl, 'n'
    jmp .show_char
.not_n:
    cmp al, 0x18    ; O
    jne .not_o
    mov bl, 'o'
    jmp .show_char
.not_o:
    cmp al, 0x19    ; P
    jne .not_p
    mov bl, 'p'
    jmp .show_char
.not_p:
    cmp al, 0x10    ; Q
    jne .not_q
    mov bl, 'q'
    jmp .show_char
.not_q:
    cmp al, 0x13    ; R
    jne .not_r
    mov bl, 'r'
    jmp .show_char
.not_r:
    cmp al, 0x1F    ; S
    jne .not_s
    mov bl, 's'
    jmp .show_char
.not_s:
    cmp al, 0x14    ; T
    jne .not_t
    mov bl, 't'
    jmp .show_char
.not_t:
    cmp al, 0x16    ; U
    jne .not_u
    mov bl, 'u'
    jmp .show_char
.not_u:
    cmp al, 0x2F    ; V
    jne .not_v
    mov bl, 'v'
    jmp .show_char
.not_v:
    cmp al, 0x11    ; W
    jne .not_w
    mov bl, 'w'
    jmp .show_char
.not_w:
    cmp al, 0x2D    ; X
    jne .not_x
    mov bl, 'x'
    jmp .show_char
.not_x:
    cmp al, 0x15    ; Y
    jne .not_y
    mov bl, 'y'
    jmp .show_char
.not_y:
    cmp al, 0x2C    ; Z
    jne .not_z
    mov bl, 'z'
    jmp .show_char
.not_z:
    cmp al, 0x39    ; Space
    jne .key_loop
    mov bl, ' '
    
.show_char:
    ; Show the character
    cmp ecx, 20     ; Limit input
    jae .key_loop
    
    mov [edi], bl
    mov byte [edi+1], 0x07    ; White on black
    add edi, 2
    inc ecx
    jmp .key_loop
    
.process_backspace:
    test ecx, ecx
    jz .key_loop
    
    sub edi, 2
    mov byte [edi], ' '
    mov byte [edi+1], 0x07
    dec ecx
    jmp .key_loop
    
.process_enter:
    ; Calculate next line dynamically
    mov eax, edi
    sub eax, VGA_BUFFER
    mov edx, 0
    mov ebx, 160        ; 80 chars * 2 bytes per char
    div ebx             ; Get current line in eax
    inc eax             ; Next line
    mov ebx, 160
    mul ebx             ; Calculate offset for next line
    add eax, VGA_BUFFER
    mov edi, eax
    
    ; Write new prompt
    mov byte [edi], '$'
    mov byte [edi+1], 0x0A     ; Green
    mov byte [edi+2], ' '
    mov byte [edi+3], 0x0A
    
    ; Set cursor after prompt
    add edi, 4
    mov ecx, 0
    jmp .key_loop

.shutdown:
    ; SSP check before exit
    pop eax                ; Restore canary address
    push eax
    call ssp_function_exit
    add esp, 4
    
    ; Infinite loop (no OS exit)
    jmp $

.security_init_failed:
    ; Display security failure message
    mov edi, VGA_BUFFER
    mov ecx, 80 * 25
    mov ax, 0x0420    ; Space with red background
    
.clear_red:
    mov [edi], ax
    add edi, 2
    loop .clear_red
    
    ; Write "SECURITY INIT FAILED" message
    mov edi, VGA_BUFFER
    mov esi, security_fail_msg
    mov ecx, security_fail_len
    mov ah, 0x4F      ; White on red
    
.write_fail_msg:
    lodsb
    mov [edi], al
    mov [edi+1], ah
    add edi, 2
    loop .write_fail_msg
    
    ; Halt system
    cli
    hlt
    jmp $

welcome_msg: db "AtomicOS v0.8.1 - Deterministic RTOS with Memory Protection"
welcome_len equ $ - welcome_msg

security_fail_msg: db "SECURITY INIT FAILED - SYSTEM HALTED"
security_fail_len equ $ - security_fail_msg

test_proc_name: db "test_task", 0

; Test process that prints characters
test_process:
    mov edi, VGA_BUFFER + (20 * 80 * 2)  ; Line 20
    mov al, 'T'
    mov ah, 0x0C  ; Red on black
    
.loop:
    mov [edi], ax
    add edi, 2
    inc al
    cmp al, 'Z'
    jle .continue
    mov al, 'A'
.continue:
    
    ; Small delay
    mov ecx, 0x100000
.delay:
    loop .delay
    
    jmp .loop

; Test real-time task
test_rt_task:
    ; Simple periodic task that runs every 1ms
    pushad
    
    ; Get task ID (simplified)
    mov eax, 1
    
.rt_loop:
    ; Do some work (toggle a flag or update counter)
    inc dword [rt_task_counter]
    
    ; Signal completion (simplified)
    ; In a real implementation, would yield to scheduler
    
    ; Busy wait to simulate work (WCET = 100us)
    mov ecx, 100
.work:
    nop
    loop .work
    
    ; Task would normally block until next period
    ; For now, just return
    popad
    ret

; Real-time task counter
rt_task_counter: dd 0

; Process name for test RT task
test_rt_name: db 'rt_test', 0

; System validation function
validate_systems:
    pushad
    
    ; Test 1: Check timer interrupt
    mov eax, [system_ticks]
    push eax
    
    ; Short delay
    mov ecx, 0x100000
.delay1:
    loop .delay1
    
    pop ebx
    cmp [system_ticks], ebx
    jne .timer_ok
    
    ; Timer not working - show error
    mov edi, VGA_BUFFER + (23 * 80 * 2)
    mov esi, timer_fail_msg
    mov ah, 0x0C  ; Red
.print_timer_fail:
    lodsb
    test al, al
    jz .done
    mov [edi], ax
    add edi, 2
    jmp .print_timer_fail
    
.timer_ok:
    ; Test 2: Quick syscall test
    mov eax, 4    ; SYS_GETPID
    int 0x80
    
    ; Check if we got a valid PID (should be non-zero)
    test eax, eax
    jz .syscall_fail
    
    ; Test 3: Memory allocation test
    push 4096          ; Size (1 page)
    push 0x07          ; Flags (RWX)
    call sys_mmap
    add esp, 8
    
    ; Check if allocation succeeded
    test eax, eax
    jz .memory_fail
    
    ; Try to write to allocated memory
    mov dword [eax], 0x12345678
    
    ; Free the memory
    push 4096          ; Size
    push eax           ; Address
    call sys_munmap
    add esp, 8
    
    ; All tests passed - show success indicator
    mov edi, VGA_BUFFER + (23 * 80 * 2) + (70 * 2)
    mov ax, 0x0A4F  ; 'O' in green (OK)
    mov [edi], ax
    mov ax, 0x0A4B  ; 'K' in green
    mov [edi + 2], ax
    jmp .done
    
.syscall_fail:
    mov edi, VGA_BUFFER + (23 * 80 * 2)
    mov esi, syscall_fail_msg
    mov ah, 0x0C  ; Red
.print_syscall_fail:
    lodsb
    test al, al
    jz .done
    mov [edi], ax
    add edi, 2
    jmp .print_syscall_fail
    jmp .done
    
.memory_fail:
    mov edi, VGA_BUFFER + (23 * 80 * 2)
    mov esi, memory_fail_msg
    mov ah, 0x0C  ; Red
.print_memory_fail:
    lodsb
    test al, al
    jz .done
    mov [edi], ax
    add edi, 2
    jmp .print_memory_fail
    
.done:
    popad
    ret

timer_fail_msg: db 'Timer interrupt not working!', 0
syscall_fail_msg: db 'Syscall interface not working!', 0
memory_fail_msg: db 'Memory protection not working!', 0

times 32768-($-$$) db 0
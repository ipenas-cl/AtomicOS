; AtomicOS Working Shell with Stack-Smashing Protection and Interrupts
[BITS 32]
[ORG 0x10000]

%define VGA_BUFFER 0xB8000

section .text
global _start

; SSP functions generated by Tempo
global STACK_CANARY
global CANARY_DEAD  
global ssp_init_canary
global ssp_set_canary
global ssp_check_canary
global ssp_handle_corruption
global ssp_function_enter
global ssp_function_exit

; Guard Pages functions generated by Tempo
global PAGE_SIZE
global GUARD_MARKER
global install_guard_page
global check_guard_violation
global handle_guard_violation
global guard_pages_init
global safe_memory_access

; Deterministic Core functions
global MEMORY_POOL_SIZE
global MEMORY_BLOCK_SIZE
global static_memory_init
global static_alloc_block
global DETERMINISTIC_SEED
global deterministic_random
global RT_PRIORITY_HIGH
global RT_PRIORITY_NORMAL
global RT_PRIORITY_LOW
global rt_task_create
global SECURITY_LEVEL_KERNEL
global SECURITY_LEVEL_SYSTEM
global SECURITY_LEVEL_USER
global SECURITY_LEVEL_GUEST
global security_check_access
global ERROR_NONE
global ERROR_INVALID_PARAM
global ERROR_OUT_OF_BOUNDS
global ERROR_TIMEOUT
global ERROR_SECURITY_VIOLATION
global deterministic_system_init

; Include Tempo-generated security and deterministic code
%include "kernel/ssp_functions.inc"
%include "kernel/guard_pages.inc"
%include "kernel/deterministic_core.inc"
%include "kernel/interrupts.inc"
%include "kernel/logo.inc"

_start:
    ; Initialize Deterministic Core System
    call deterministic_system_init
    test eax, eax
    jnz .security_init_failed
    
    ; Initialize Guard Pages system
    call guard_pages_init
    test eax, eax
    jz .security_init_failed
    
    ; Initialize SSP protection for main function
    push esp                ; Pass current stack pointer
    call ssp_function_enter
    add esp, 4
    push eax               ; Save canary address for later exit
    
    ; Initialize interrupt system
    call init_idt          ; Set up IDT with all handlers
    call load_idt          ; Load the IDT
    call init_timer        ; Initialize timer for scheduling
    call enable_interrupts ; Enable interrupts (STI)
    
    ; Clear screen exactly like debug test
    mov edi, VGA_BUFFER
    mov ecx, 80 * 25
    mov ax, 0x0720    ; Space with white on black
    
.clear:
    mov [edi], ax
    add edi, 2
    loop .clear
    
    ; Display AtomicOS logo
    mov edi, VGA_BUFFER + (5 * 80 * 2)  ; Start at line 5
    mov esi, atomicos_logo
    mov ebx, logo_lines
    
.logo_loop:
    push edi
    push esi
    
    ; Center the logo (each line is 50 chars, center in 80 cols)
    add edi, 15 * 2  ; Move 15 chars to the right
    
.logo_line:
    lodsb
    test al, al
    jz .next_logo_line
    mov [edi], al
    mov byte [edi+1], 0x0B  ; Cyan on black
    add edi, 2
    jmp .logo_line
    
.next_logo_line:
    pop esi
    pop edi
    
    ; Skip to next string
.find_next:
    lodsb
    test al, al
    jnz .find_next
    
    add edi, 160  ; Next line
    dec ebx
    jnz .logo_loop
    
    ; Write welcome message - AtomicOS Deterministic
    mov edi, VGA_BUFFER
    mov esi, welcome_msg
    mov ecx, welcome_len
    mov ah, 0x0A          ; Green on black
    
.write_welcome:
    lodsb
    mov [edi], al
    mov [edi+1], ah
    add edi, 2
    loop .write_welcome
    
    ; Write prompt on second line
    mov edi, VGA_BUFFER + 160  ; Second line
    mov byte [edi], '$'
    mov byte [edi+1], 0x0A     ; Green
    mov byte [edi+2], ' '
    mov byte [edi+3], 0x0A
    
    ; Set cursor position for input
    mov edi, VGA_BUFFER + 164  ; After prompt
    mov ecx, 0                 ; Character count
    
.key_loop:
    ; Wait for key
    in al, 0x64
    test al, 1
    jz .key_loop
    
    ; Read scancode
    in al, 0x60
    
    ; Ignore releases
    test al, 0x80
    jnz .key_loop
    
    ; Check Enter (scancode 0x1C)
    cmp al, 0x1C
    je .process_enter
    
    ; Check Backspace (scancode 0x0E)
    cmp al, 0x0E
    je .process_backspace
    
    ; Convert common scancodes to ASCII
    mov bl, 0
    cmp al, 0x1E    ; A
    jne .not_a
    mov bl, 'a'
    jmp .show_char
.not_a:
    cmp al, 0x30    ; B
    jne .not_b
    mov bl, 'b'
    jmp .show_char
.not_b:
    cmp al, 0x2E    ; C
    jne .not_c
    mov bl, 'c'
    jmp .show_char
.not_c:
    cmp al, 0x20    ; D
    jne .not_d
    mov bl, 'd'
    jmp .show_char
.not_d:
    cmp al, 0x12    ; E
    jne .not_e
    mov bl, 'e'
    jmp .show_char
.not_e:
    cmp al, 0x21    ; F
    jne .not_f
    mov bl, 'f'
    jmp .show_char
.not_f:
    cmp al, 0x22    ; G
    jne .not_g
    mov bl, 'g'
    jmp .show_char
.not_g:
    cmp al, 0x23    ; H
    jne .not_h
    mov bl, 'h'
    jmp .show_char
.not_h:
    cmp al, 0x17    ; I
    jne .not_i
    mov bl, 'i'
    jmp .show_char
.not_i:
    cmp al, 0x24    ; J
    jne .not_j
    mov bl, 'j'
    jmp .show_char
.not_j:
    cmp al, 0x25    ; K
    jne .not_k
    mov bl, 'k'
    jmp .show_char
.not_k:
    cmp al, 0x26    ; L
    jne .not_l
    mov bl, 'l'
    jmp .show_char
.not_l:
    cmp al, 0x32    ; M
    jne .not_m
    mov bl, 'm'
    jmp .show_char
.not_m:
    cmp al, 0x31    ; N
    jne .not_n
    mov bl, 'n'
    jmp .show_char
.not_n:
    cmp al, 0x18    ; O
    jne .not_o
    mov bl, 'o'
    jmp .show_char
.not_o:
    cmp al, 0x19    ; P
    jne .not_p
    mov bl, 'p'
    jmp .show_char
.not_p:
    cmp al, 0x10    ; Q
    jne .not_q
    mov bl, 'q'
    jmp .show_char
.not_q:
    cmp al, 0x13    ; R
    jne .not_r
    mov bl, 'r'
    jmp .show_char
.not_r:
    cmp al, 0x1F    ; S
    jne .not_s
    mov bl, 's'
    jmp .show_char
.not_s:
    cmp al, 0x14    ; T
    jne .not_t
    mov bl, 't'
    jmp .show_char
.not_t:
    cmp al, 0x16    ; U
    jne .not_u
    mov bl, 'u'
    jmp .show_char
.not_u:
    cmp al, 0x2F    ; V
    jne .not_v
    mov bl, 'v'
    jmp .show_char
.not_v:
    cmp al, 0x11    ; W
    jne .not_w
    mov bl, 'w'
    jmp .show_char
.not_w:
    cmp al, 0x2D    ; X
    jne .not_x
    mov bl, 'x'
    jmp .show_char
.not_x:
    cmp al, 0x15    ; Y
    jne .not_y
    mov bl, 'y'
    jmp .show_char
.not_y:
    cmp al, 0x2C    ; Z
    jne .not_z
    mov bl, 'z'
    jmp .show_char
.not_z:
    cmp al, 0x39    ; Space
    jne .key_loop
    mov bl, ' '
    
.show_char:
    ; Show the character
    cmp ecx, 20     ; Limit input
    jae .key_loop
    
    mov [edi], bl
    mov byte [edi+1], 0x07    ; White on black
    add edi, 2
    inc ecx
    jmp .key_loop
    
.process_backspace:
    test ecx, ecx
    jz .key_loop
    
    sub edi, 2
    mov byte [edi], ' '
    mov byte [edi+1], 0x07
    dec ecx
    jmp .key_loop
    
.process_enter:
    ; Calculate next line dynamically
    mov eax, edi
    sub eax, VGA_BUFFER
    mov edx, 0
    mov ebx, 160        ; 80 chars * 2 bytes per char
    div ebx             ; Get current line in eax
    inc eax             ; Next line
    mov ebx, 160
    mul ebx             ; Calculate offset for next line
    add eax, VGA_BUFFER
    mov edi, eax
    
    ; Write new prompt
    mov byte [edi], '$'
    mov byte [edi+1], 0x0A     ; Green
    mov byte [edi+2], ' '
    mov byte [edi+3], 0x0A
    
    ; Set cursor after prompt
    add edi, 4
    mov ecx, 0
    jmp .key_loop

.shutdown:
    ; SSP check before exit
    pop eax                ; Restore canary address
    push eax
    call ssp_function_exit
    add esp, 4
    
    ; Infinite loop (no OS exit)
    jmp $

.security_init_failed:
    ; Display security failure message
    mov edi, VGA_BUFFER
    mov ecx, 80 * 25
    mov ax, 0x0420    ; Space with red background
    
.clear_red:
    mov [edi], ax
    add edi, 2
    loop .clear_red
    
    ; Write "SECURITY INIT FAILED" message
    mov edi, VGA_BUFFER
    mov esi, security_fail_msg
    mov ecx, security_fail_len
    mov ah, 0x4F      ; White on red
    
.write_fail_msg:
    lodsb
    mov [edi], al
    mov [edi+1], ah
    add edi, 2
    loop .write_fail_msg
    
    ; Halt system
    cli
    hlt
    jmp $

welcome_msg: db "AtomicOS v0.8.0 - Deterministic Real-Time Security OS"
welcome_len equ $ - welcome_msg

security_fail_msg: db "SECURITY INIT FAILED - SYSTEM HALTED"
security_fail_len equ $ - security_fail_msg

times 16384-($-$$) db 0
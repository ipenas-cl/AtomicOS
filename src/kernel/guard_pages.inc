; Guard Pages Protection - Generated by Tempo
; AtomicOS v0.6.1 - Deterministic Memory Protection

PAGE_SIZE:
    push ebp
    mov ebp, esp
    sub esp, 16
    mov eax, 4096
    push eax
    pop eax
    jmp .func_end
.func_end:
    mov esp, ebp
    pop ebp
    ret

GUARD_MARKER:
    push ebp
    mov ebp, esp
    sub esp, 16
    mov eax, 3735928559  ; 0xDEADBEEF
    push eax
    pop eax
    jmp .func_end
.func_end:
    mov esp, ebp
    pop ebp
    ret

install_guard_page:
    push ebp
    mov ebp, esp
    sub esp, 16
    ; Check page alignment: guard_addr & (PAGE_SIZE - 1) != 0
    mov eax, [ebp+8]     ; guard_addr parameter
    push eax
    call PAGE_SIZE
    push eax
    mov eax, 1
    push eax
    pop ebx
    pop eax
    sub eax, ebx
    push eax
    pop ebx
    pop eax
    and eax, ebx
    push eax
    mov eax, 0
    push eax
    pop ebx
    pop eax
    cmp eax, ebx
    sete al
    movzx eax, al
    push eax
    pop eax
    test eax, eax
    jz .alignment_ok
    mov eax, 0           ; Return failure for misaligned
    jmp .func_end
.alignment_ok:
    ; Check address range: 0x100000 <= addr < 0x400000
    mov eax, [ebp+8]     ; guard_addr parameter
    cmp eax, 0x100000
    jl .range_error
    cmp eax, 0x400000
    jge .range_error
    ; Return success marker
    call GUARD_MARKER
    jmp .func_end
.range_error:
    mov eax, 0           ; Return failure
.func_end:
    mov esp, ebp
    pop ebp
    ret

check_guard_violation:
    push ebp
    mov ebp, esp
    sub esp, 16
    ; Calculate page start: access_addr & ~(PAGE_SIZE - 1)
    mov eax, [ebp+8]     ; access_addr parameter
    push eax
    call PAGE_SIZE
    push eax
    mov eax, 1
    push eax
    pop ebx
    pop eax
    sub eax, ebx
    push eax
    pop eax
    not eax
    push eax
    pop ebx
    pop eax
    and eax, ebx
    mov [ebp-4], eax     ; page_start
    
    ; Check if this is a page boundary access
    mov eax, [ebp-4]     ; page_start
    and eax, 0xFFF
    cmp eax, 0
    jne .no_violation
    
    ; Check against known guard page (0x200000-0x201000)
    mov eax, [ebp+8]     ; access_addr
    cmp eax, 0x200000
    jl .no_violation
    cmp eax, 0x201000
    jge .no_violation
    
    mov eax, 1           ; Violation detected
    jmp .func_end
.no_violation:
    mov eax, 0           ; No violation
.func_end:
    mov esp, ebp
    pop ebp
    ret

handle_guard_violation:
    push ebp
    mov ebp, esp
    sub esp, 16
    ; Return error code: 0xDEAD0000 | (addr & 0xFFFF)
    mov eax, 0xDEAD0000
    push eax
    mov eax, [ebp+8]     ; violation_addr parameter
    and eax, 0xFFFF
    push eax
    pop ebx
    pop eax
    or eax, ebx
    jmp .func_end
.func_end:
    mov esp, ebp
    pop ebp
    ret

guard_pages_init:
    push ebp
    mov ebp, esp
    sub esp, 16
    ; Install stack guard at 0x200000
    push 0x200000
    call install_guard_page
    add esp, 4
    mov [ebp-4], eax     ; stack_guard
    
    ; Install heap guard at 0x300000
    push 0x300000
    call install_guard_page
    add esp, 4
    mov [ebp-8], eax     ; heap_guard
    
    ; Install kernel guard at 0x100000
    push 0x100000
    call install_guard_page
    add esp, 4
    mov [ebp-12], eax    ; kernel_guard
    
    ; Check if all guards installed successfully
    cmp dword [ebp-4], 0   ; stack_guard == 0?
    je .init_failed
    cmp dword [ebp-8], 0   ; heap_guard == 0?
    je .init_failed
    cmp dword [ebp-12], 0  ; kernel_guard == 0?
    je .init_failed
    
    mov eax, 1           ; Success
    jmp .func_end
.init_failed:
    mov eax, 0           ; Failure
.func_end:
    mov esp, ebp
    pop ebp
    ret

safe_memory_access:
    push ebp
    mov ebp, esp
    sub esp, 16
    ; Check for guard page violation
    push dword [ebp+8]   ; addr parameter
    call check_guard_violation
    add esp, 4
    mov [ebp-4], eax     ; violation result
    
    ; If violation detected, handle it
    cmp dword [ebp-4], 0
    je .no_violation
    push dword [ebp+8]   ; addr parameter
    call handle_guard_violation
    add esp, 4
    jmp .func_end
    
.no_violation:
    ; Validate access_type (1=read, 2=write, 3=execute)
    mov eax, [ebp+12]    ; access_type parameter
    cmp eax, 1
    jl .invalid_access
    cmp eax, 3
    jg .invalid_access
    
    ; Check address bounds (0x10000 <= addr <= 0x510000)
    ; Allow access to deterministic memory pool at 0x500000 (64KB)
    mov eax, [ebp+8]     ; addr parameter
    cmp eax, 0x10000
    jl .out_of_bounds
    cmp eax, 0x510000    ; 0x500000 + 64KB
    jg .out_of_bounds
    
    mov eax, 1           ; Access allowed
    jmp .func_end
    
.invalid_access:
.out_of_bounds:
    mov eax, 0           ; Access denied
.func_end:
    mov esp, ebp
    pop ebp
    ret
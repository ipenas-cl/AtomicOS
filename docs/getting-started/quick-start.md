# AtomicOS Quick Start Guide

Welcome to AtomicOS! This guide will get you up and running in minutes.

## Prerequisites

Make sure you've completed the [installation](installation.md) process.

## Your First AtomicOS Session

### 1. Build and Run

```bash
# Build everything
make all

# Run AtomicOS
make run
```

You should see the AtomicOS boot screen in your terminal.

### 2. Understanding the Boot Process

AtomicOS boots through these stages:
1. **Bootloader**: Loads the kernel into memory
2. **Kernel Init**: Sets up memory, interrupts, and security
3. **Security Modules**: Initializes Tempo-based security components
4. **Ready State**: System ready for operations

## Writing Your First Tempo Program

### 1. Create a Simple Module

Create `examples/hello_atomic.tempo`:

```tempo
// My first Tempo program
function hello_atomic() -> int32 {
    // Direct VGA memory write
    let vga_base = 0xB8000;
    
    // Write 'H' in white on black
    memory_write8(vga_base, 72);        // 'H'
    memory_write8(vga_base + 1, 0x0F);  // Attribute
    
    return 0;
}

function main() -> int32 {
    return hello_atomic();
}
```

### 2. Compile Your Program

```bash
./build/tempo_compiler examples/hello_atomic.tempo build/hello_atomic.s
```

### 3. Examine the Output

```bash
cat build/hello_atomic.s
```

You'll see optimized x86 assembly generated by Tempo.

## Exploring Tempo Features

### Memory Safety

```tempo
// Tempo prevents buffer overflows
function safe_copy(dst: ptr<int8, 10>, src: ptr<int8, 10>) {
    for i in 0..10 {
        dst[i] = src[i];  // Bounds checked!
    }
}
```

### Real-Time Guarantees

```tempo
// Loops must have bounded iterations
function process_data() -> int32 @wcet(1000) {
    let sum = 0;
    
    while @wcet(100) i < 100 {
        sum = sum + data[i];
        i = i + 1;
    }
    
    return sum;
}
```

### Security Annotations

```tempo
// Constant-time crypto operations
function crypto_compare(a: ptr<int8, 32>, b: ptr<int8, 32>) -> bool @constant_time {
    let diff = 0;
    
    for i in 0..32 {
        diff = diff | (a[i] ^ b[i]);
    }
    
    return diff == 0;
}
```

## Working with the Kernel

### Understanding Security Levels

AtomicOS has 4 security levels:
- **Level 3 (Kernel)**: Highest privilege
- **Level 2 (System)**: System services
- **Level 1 (User)**: User applications
- **Level 0 (Guest)**: Untrusted code

### Interacting with Hardware

```tempo
// Port I/O example
function beep() {
    // PC speaker control
    io_out8(0x61, io_in8(0x61) | 3);
    io_out8(0x43, 0xB6);
    io_out8(0x42, 0x53);  // Frequency low byte
    io_out8(0x42, 0x05);  // Frequency high byte
}
```

## Common Tasks

### Reading System State

```tempo
function get_cpu_flags() -> int32 {
    asm {
        "pushf"
        "pop eax"
    }
}
```

### Implementing a Device Driver

```tempo
struct DeviceRegisters {
    control: int32,
    status: int32,
    data: int32
}

function driver_init(base: int32) -> int32 {
    let regs = base as ptr<DeviceRegisters>;
    
    // Reset device
    regs->control = 0x01;
    
    // Wait for ready
    while (regs->status & 0x01) == 0 {
        cpu_pause();
    }
    
    return 0;
}
```

## Testing Your Code

### 1. Unit Testing

```bash
# Run all tests
make test

# Run specific test
./build/tempo_compiler examples/my_test.tempo build/test.s
```

### 2. Integration Testing

Modify `src/kernel/kernel.asm` to include your module:

```asm
%include "build/my_module.inc"

; Call your function
call my_function
```

## Debugging Tips

### 1. Use Debug Output

```tempo
function debug_print(value: int32) {
    // Write to debug port (QEMU)
    io_out32(0xE9, value);
}
```

### 2. GDB Debugging

```bash
# Terminal 1
make debug

# Terminal 2
gdb build/kernel.elf
(gdb) target remote :1234
(gdb) break my_function
(gdb) continue
```

## Best Practices

### DO:
- ✅ Always specify WCET bounds
- ✅ Use type annotations
- ✅ Check return values
- ✅ Clear sensitive data
- ✅ Test edge cases

### DON'T:
- ❌ Use unbounded loops
- ❌ Ignore compiler warnings
- ❌ Assume memory layout
- ❌ Skip security checks
- ❌ Use dynamic allocation

## Example Projects

Explore these examples to learn more:

1. **Basic Examples**
   - `examples/hello.tempo` - Simple output
   - `examples/arithmetic.tempo` - Math operations
   - `examples/control_flow.tempo` - Conditionals and loops

2. **System Programming**
   - `examples/intrinsics_vga_hello.tempo` - VGA graphics
   - `examples/io_operations.tempo` - Hardware I/O
   - `examples/inline_asm.tempo` - Assembly integration

3. **Security Modules**
   - `examples/deterministic_core.tempo` - Core security
   - `examples/guard_pages.tempo` - Memory protection
   - `examples/ssp_functions.tempo` - Stack protection

4. **Advanced Features**
   - `examples/realtime_scheduler.tempo` - RT scheduling
   - `examples/kaslr.tempo` - Address randomization
   - `examples/wx_protection.tempo` - W^X enforcement

## Next Steps

1. **Learn Tempo**: Read the [Tempo Language Reference](../tempo/README.md)
2. **Understand Architecture**: Study the [Architecture Overview](../architecture/overview.md)
3. **Contribute**: Check the [Developer Guide](../development/dev-guide.md)
4. **Get Help**: Join the [community discussions](https://github.com/ipenas-cl/AtomicOS/discussions)

---
*Remember: Security First, Stability Second, Performance Third*
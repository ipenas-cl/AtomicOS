// Tempo Shell - A deterministic command interpreter for AtomicOS
// No more bash complexity - pure determinism

import kernel::process::{create_process, exit, wait_pid};
import kernel::fs::{open, read, write, close, stat, readdir};
import kernel::ipc::{create_pipe, send_message, receive_message};
import std::str::{len, copy, compare, find_char, concat};
import std::convert::{int_to_str, str_to_int};
import std::io::{read_line, write_string};

// Shell constants
const MAX_COMMAND_LENGTH: int32 = 256;
const MAX_ARGS: int32 = 16;
const MAX_PATH: int32 = 256;
const HISTORY_SIZE: int32 = 100;

// Built-in commands
const BUILTIN_CD: int32 = 0;
const BUILTIN_PWD: int32 = 1;
const BUILTIN_LS: int32 = 2;
const BUILTIN_CAT: int32 = 3;
const BUILTIN_ECHO: int32 = 4;
const BUILTIN_EXIT: int32 = 5;
const BUILTIN_HELP: int32 = 6;
const BUILTIN_PS: int32 = 7;
const BUILTIN_KILL: int32 = 8;

// Command structure
struct Command {
    name: int8[64],
    args: ptr<int8, MAX_ARGS>[MAX_ARGS],
    arg_count: int32,
    input_redirect: int8[MAX_PATH],
    output_redirect: int8[MAX_PATH],
    append_output: bool,
    background: bool,
    pipe_next: bool
}

// Shell state
struct ShellState {
    current_dir: int8[MAX_PATH],
    history: int8[HISTORY_SIZE][MAX_COMMAND_LENGTH],
    history_count: int32,
    history_index: int32,
    last_exit_code: int32,
    env_vars: EnvironmentVar[32],
    env_count: int32
}

struct EnvironmentVar {
    name: int8[32],
    value: int8[128]
}

// Global shell state
static shell: ShellState;

// Main shell entry point
@wcet(infinite)
@export
function shell_main(): int32 {
    // Initialize shell
    init_shell();
    
    // Print welcome message
    write_string("AtomicOS Tempo Shell v1.0\n");
    write_string("Type 'help' for available commands\n\n");
    
    // Main shell loop
    while (true) [max infinite] {
        // Print prompt
        print_prompt();
        
        // Read command
        let command_line: int8[MAX_COMMAND_LENGTH];
        if (!read_line(command_line, MAX_COMMAND_LENGTH)) {
            continue;
        }
        
        // Add to history
        add_to_history(command_line);
        
        // Parse command
        let cmd: Command;
        if (!parse_command(command_line, &cmd)) {
            write_string("tempo-sh: parse error\n");
            continue;
        }
        
        // Execute command
        shell.last_exit_code = execute_command(&cmd);
    }
    
    return 0;
}

@wcet(100)
function init_shell(): void {
    // Set initial directory
    str::copy(shell.current_dir, "/", MAX_PATH);
    
    // Initialize history
    shell.history_count = 0;
    shell.history_index = 0;
    
    // Set default environment variables
    set_env("PATH", "/bin:/usr/bin");
    set_env("HOME", "/home/user");
    set_env("SHELL", "/bin/tempo-sh");
}

@wcet(50)
function print_prompt(): void {
    write_string("[");
    write_string(shell.current_dir);
    write_string("]$ ");
}

@wcet(200)
function add_to_history(cmd: ptr<int8, MAX_COMMAND_LENGTH>): void {
    if (shell.history_count < HISTORY_SIZE) {
        str::copy(shell.history[shell.history_count], cmd, MAX_COMMAND_LENGTH);
        shell.history_count++;
    } else {
        // Shift history up
        for (i: int32 = 0; i < HISTORY_SIZE - 1; i++) [max HISTORY_SIZE] {
            str::copy(shell.history[i], shell.history[i + 1], MAX_COMMAND_LENGTH);
        }
        str::copy(shell.history[HISTORY_SIZE - 1], cmd, MAX_COMMAND_LENGTH);
    }
    shell.history_index = shell.history_count;
}

@wcet(500)
function parse_command(line: ptr<int8, MAX_COMMAND_LENGTH>, cmd: ptr<Command, 1>): bool {
    // Initialize command structure
    cmd.arg_count = 0;
    cmd.input_redirect[0] = 0;
    cmd.output_redirect[0] = 0;
    cmd.append_output = false;
    cmd.background = false;
    cmd.pipe_next = false;
    
    let i: int32 = 0;
    let token_start: int32 = -1;
    let in_quotes: bool = false;
    
    // Skip leading whitespace
    while (i < MAX_COMMAND_LENGTH && (line[i] == ' ' || line[i] == '\t')) [max MAX_COMMAND_LENGTH] {
        i++;
    }
    
    // Parse tokens
    while (i < MAX_COMMAND_LENGTH && line[i] != 0) [max MAX_COMMAND_LENGTH] {
        let c: int8 = line[i];
        
        // Handle quotes
        if (c == '"' && !in_quotes) {
            in_quotes = true;
            token_start = i + 1;
        } else if (c == '"' && in_quotes) {
            in_quotes = false;
            // Extract token
            if (cmd.arg_count == 0) {
                extract_token(line, token_start, i - 1, cmd.name, 64);
            } else if (cmd.arg_count < MAX_ARGS) {
                extract_token(line, token_start, i - 1, 
                            cmd.args[cmd.arg_count - 1], MAX_PATH);
            }
            token_start = -1;
        }
        // Handle special characters
        else if (!in_quotes) {
            if (c == ' ' || c == '\t') {
                if (token_start >= 0) {
                    // End of token
                    if (cmd.arg_count == 0) {
                        extract_token(line, token_start, i - 1, cmd.name, 64);
                        cmd.arg_count = 1;
                    } else if (cmd.arg_count < MAX_ARGS) {
                        cmd.args[cmd.arg_count - 1] = allocate_string(MAX_PATH);
                        extract_token(line, token_start, i - 1,
                                    cmd.args[cmd.arg_count - 1], MAX_PATH);
                        cmd.arg_count++;
                    }
                    token_start = -1;
                }
            } else if (c == '<') {
                // Input redirection
                i++;
                skip_whitespace(line, &i);
                extract_until_special(line, i, cmd.input_redirect, MAX_PATH);
            } else if (c == '>') {
                // Output redirection
                i++;
                if (line[i] == '>') {
                    cmd.append_output = true;
                    i++;
                }
                skip_whitespace(line, &i);
                extract_until_special(line, i, cmd.output_redirect, MAX_PATH);
            } else if (c == '|') {
                // Pipe
                cmd.pipe_next = true;
                break;
            } else if (c == '&') {
                // Background
                cmd.background = true;
                break;
            } else if (token_start < 0) {
                token_start = i;
            }
        }
        
        i++;
    }
    
    // Handle last token
    if (token_start >= 0 && !in_quotes) {
        if (cmd.arg_count == 0) {
            extract_token(line, token_start, i - 1, cmd.name, 64);
            cmd.arg_count = 1;
        } else if (cmd.arg_count < MAX_ARGS) {
            cmd.args[cmd.arg_count - 1] = allocate_string(MAX_PATH);
            extract_token(line, token_start, i - 1,
                        cmd.args[cmd.arg_count - 1], MAX_PATH);
            cmd.arg_count++;
        }
    }
    
    return cmd.name[0] != 0;
}

@wcet(100)
function execute_command(cmd: ptr<Command, 1>): int32 {
    // Check for built-in commands
    let builtin_id: int32 = get_builtin_id(cmd.name);
    if (builtin_id >= 0) {
        return execute_builtin(builtin_id, cmd);
    }
    
    // Execute external command
    return execute_external(cmd);
}

@wcet(50)
function get_builtin_id(name: ptr<int8, 64>): int32 {
    if (str::compare(name, "cd", 64) == 0) return BUILTIN_CD;
    if (str::compare(name, "pwd", 64) == 0) return BUILTIN_PWD;
    if (str::compare(name, "ls", 64) == 0) return BUILTIN_LS;
    if (str::compare(name, "cat", 64) == 0) return BUILTIN_CAT;
    if (str::compare(name, "echo", 64) == 0) return BUILTIN_ECHO;
    if (str::compare(name, "exit", 64) == 0) return BUILTIN_EXIT;
    if (str::compare(name, "help", 64) == 0) return BUILTIN_HELP;
    if (str::compare(name, "ps", 64) == 0) return BUILTIN_PS;
    if (str::compare(name, "kill", 64) == 0) return BUILTIN_KILL;
    return -1;
}

@wcet(1000)
function execute_builtin(id: int32, cmd: ptr<Command, 1>): int32 {
    match id {
        BUILTIN_CD => return builtin_cd(cmd),
        BUILTIN_PWD => return builtin_pwd(cmd),
        BUILTIN_LS => return builtin_ls(cmd),
        BUILTIN_CAT => return builtin_cat(cmd),
        BUILTIN_ECHO => return builtin_echo(cmd),
        BUILTIN_EXIT => return builtin_exit(cmd),
        BUILTIN_HELP => return builtin_help(cmd),
        BUILTIN_PS => return builtin_ps(cmd),
        BUILTIN_KILL => return builtin_kill(cmd),
        _ => return -1
    }
}

// Built-in command implementations

@wcet(200)
function builtin_cd(cmd: ptr<Command, 1>): int32 {
    let path: ptr<int8, MAX_PATH>;
    
    if (cmd.arg_count <= 1) {
        // No argument - go to home
        path = get_env("HOME");
        if (!path) {
            path = "/";
        }
    } else {
        path = cmd.args[0];
    }
    
    // Check if path exists and is directory
    let info: FileInfo;
    if (stat(path, &info) < 0) {
        write_string("cd: ");
        write_string(path);
        write_string(": No such file or directory\n");
        return 1;
    }
    
    if (!info.is_directory) {
        write_string("cd: ");
        write_string(path);
        write_string(": Not a directory\n");
        return 1;
    }
    
    // Update current directory
    if (path[0] == '/') {
        // Absolute path
        str::copy(shell.current_dir, path, MAX_PATH);
    } else {
        // Relative path
        resolve_path(shell.current_dir, path, shell.current_dir);
    }
    
    return 0;
}

@wcet(50)
function builtin_pwd(cmd: ptr<Command, 1>): int32 {
    write_string(shell.current_dir);
    write_string("\n");
    return 0;
}

@wcet(2000)
function builtin_ls(cmd: ptr<Command, 1>): int32 {
    let path: ptr<int8, MAX_PATH> = shell.current_dir;
    
    if (cmd.arg_count > 1) {
        path = cmd.args[0];
    }
    
    let dir: Directory;
    if (opendir(path, &dir) < 0) {
        write_string("ls: cannot access '");
        write_string(path);
        write_string("': No such file or directory\n");
        return 1;
    }
    
    let entry: DirectoryEntry;
    while (readdir(&dir, &entry) == 0) [max 1000] {
        // Skip . and ..
        if (str::compare(entry.name, ".", 256) == 0 ||
            str::compare(entry.name, "..", 256) == 0) {
            continue;
        }
        
        // Get file info
        let full_path: int8[MAX_PATH];
        str::copy(full_path, path, MAX_PATH);
        str::concat(full_path, "/", MAX_PATH);
        str::concat(full_path, entry.name, MAX_PATH);
        
        let info: FileInfo;
        if (stat(full_path, &info) == 0) {
            // Print with color based on type
            if (info.is_directory) {
                write_string("\x1b[34m");  // Blue for directories
            } else if (info.is_executable) {
                write_string("\x1b[32m");  // Green for executables
            }
            
            write_string(entry.name);
            
            if (info.is_directory) {
                write_string("/");
            } else if (info.is_executable) {
                write_string("*");
            }
            
            write_string("\x1b[0m");  // Reset color
            write_string("  ");
        }
    }
    
    write_string("\n");
    closedir(&dir);
    return 0;
}

@wcet(5000)
function builtin_cat(cmd: ptr<Command, 1>): int32 {
    if (cmd.arg_count <= 1) {
        write_string("cat: missing operand\n");
        return 1;
    }
    
    for (i: int32 = 0; i < cmd.arg_count - 1; i++) [max MAX_ARGS] {
        let fd: int32 = open(cmd.args[i], O_RDONLY);
        if (fd < 0) {
            write_string("cat: ");
            write_string(cmd.args[i]);
            write_string(": No such file or directory\n");
            continue;
        }
        
        let buffer: int8[1024];
        let bytes_read: int32;
        
        while ((bytes_read = read(fd, buffer, 1024)) > 0) [max 1000] {
            write(STDOUT_FILENO, buffer, bytes_read);
        }
        
        close(fd);
    }
    
    return 0;
}

@wcet(200)
function builtin_echo(cmd: ptr<Command, 1>): int32 {
    for (i: int32 = 0; i < cmd.arg_count - 1; i++) [max MAX_ARGS] {
        write_string(cmd.args[i]);
        if (i < cmd.arg_count - 2) {
            write_string(" ");
        }
    }
    write_string("\n");
    return 0;
}

@wcet(50)
function builtin_exit(cmd: ptr<Command, 1>): int32 {
    let exit_code: int32 = 0;
    
    if (cmd.arg_count > 1) {
        match str_to_int(cmd.args[0], MAX_PATH) {
            Result::Ok(code) => exit_code = code,
            Result::Err(_) => exit_code = 1
        }
    }
    
    exit(exit_code);
    return 0;  // Never reached
}

@wcet(500)
function builtin_help(cmd: ptr<Command, 1>): int32 {
    write_string("AtomicOS Tempo Shell Built-in Commands:\n\n");
    write_string("  cd [dir]     - Change directory\n");
    write_string("  pwd          - Print working directory\n");
    write_string("  ls [dir]     - List directory contents\n");
    write_string("  cat file...  - Concatenate files\n");
    write_string("  echo args... - Display arguments\n");
    write_string("  ps           - List processes\n");
    write_string("  kill pid     - Terminate process\n");
    write_string("  help         - Show this help\n");
    write_string("  exit [code]  - Exit shell\n");
    write_string("\nFeatures:\n");
    write_string("  - Input/output redirection: < > >>\n");
    write_string("  - Pipes: |\n");
    write_string("  - Background execution: &\n");
    write_string("  - Command history: up/down arrows\n");
    return 0;
}

@wcet(1000)
function builtin_ps(cmd: ptr<Command, 1>): int32 {
    write_string("PID\tSTATE\tNAME\n");
    
    let procs: ProcessInfo[64];
    let count: int32 = get_process_list(procs, 64);
    
    for (i: int32 = 0; i < count; i++) [max 64] {
        let pid_str: int8[12];
        int_to_str(procs[i].pid, pid_str);
        write_string(pid_str);
        write_string("\t");
        
        match procs[i].state {
            PROCESS_READY => write_string("READY"),
            PROCESS_RUNNING => write_string("RUN"),
            PROCESS_BLOCKED => write_string("BLOCK"),
            PROCESS_ZOMBIE => write_string("ZOMB"),
            _ => write_string("?")
        }
        write_string("\t");
        
        write_string(procs[i].name);
        write_string("\n");
    }
    
    return 0;
}

@wcet(100)
function builtin_kill(cmd: ptr<Command, 1>): int32 {
    if (cmd.arg_count <= 1) {
        write_string("kill: missing pid\n");
        return 1;
    }
    
    match str_to_int(cmd.args[0], MAX_PATH) {
        Result::Ok(pid) => {
            if (kill_process(pid) < 0) {
                write_string("kill: failed to terminate process\n");
                return 1;
            }
        },
        Result::Err(_) => {
            write_string("kill: invalid pid\n");
            return 1;
        }
    }
    
    return 0;
}

// External command execution
@wcet(1000)
function execute_external(cmd: ptr<Command, 1>): int32 {
    // Search for command in PATH
    let full_path: int8[MAX_PATH];
    if (!find_in_path(cmd.name, full_path)) {
        write_string("tempo-sh: ");
        write_string(cmd.name);
        write_string(": command not found\n");
        return 127;
    }
    
    // Create pipes if needed
    let pipe_fds: int32[2];
    if (cmd.pipe_next) {
        if (create_pipe(pipe_fds) < 0) {
            write_string("tempo-sh: pipe creation failed\n");
            return 1;
        }
    }
    
    // Fork and execute
    match create_process(full_path, cmd.args, cmd.arg_count - 1) {
        Result::Ok(pid) => {
            if (!cmd.background) {
                // Wait for completion
                let status: int32;
                wait_pid(pid, &status);
                return status;
            }
            return 0;
        },
        Result::Err(_) => {
            write_string("tempo-sh: failed to execute ");
            write_string(cmd.name);
            write_string("\n");
            return 1;
        }
    }
}

// Utility functions
@wcet(500)
function find_in_path(name: ptr<int8, 64>, result: ptr<int8, MAX_PATH>): bool {
    // If name contains /, use as-is
    if (str::find_char(name, '/', 64) >= 0) {
        str::copy(result, name, MAX_PATH);
        let info: FileInfo;
        return stat(result, &info) == 0 && info.is_executable;
    }
    
    // Search in PATH
    let path_env: ptr<int8, 128> = get_env("PATH");
    if (!path_env) {
        return false;
    }
    
    let path_copy: int8[128];
    str::copy(path_copy, path_env, 128);
    
    let start: int32 = 0;
    for (i: int32 = 0; i <= str::len(path_copy, 128); i++) [max 128] {
        if (path_copy[i] == ':' || path_copy[i] == 0) {
            // Extract path component
            let component: int8[MAX_PATH];
            extract_token(path_copy, start, i - 1, component, MAX_PATH);
            
            // Build full path
            str::copy(result, component, MAX_PATH);
            str::concat(result, "/", MAX_PATH);
            str::concat(result, name, MAX_PATH);
            
            // Check if exists and executable
            let info: FileInfo;
            if (stat(result, &info) == 0 && info.is_executable) {
                return true;
            }
            
            start = i + 1;
        }
    }
    
    return false;
}

@wcet(100)
function set_env(name: ptr<int8, 32>, value: ptr<int8, 128>): void {
    for (i: int32 = 0; i < shell.env_count; i++) [max 32] {
        if (str::compare(shell.env_vars[i].name, name, 32) == 0) {
            str::copy(shell.env_vars[i].value, value, 128);
            return;
        }
    }
    
    if (shell.env_count < 32) {
        str::copy(shell.env_vars[shell.env_count].name, name, 32);
        str::copy(shell.env_vars[shell.env_count].value, value, 128);
        shell.env_count++;
    }
}

@wcet(50)
function get_env(name: ptr<int8, 32>): ptr<int8, 128> {
    for (i: int32 = 0; i < shell.env_count; i++) [max 32] {
        if (str::compare(shell.env_vars[i].name, name, 32) == 0) {
            return shell.env_vars[i].value;
        }
    }
    return null;
}
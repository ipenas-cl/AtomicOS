// EXAMPLE 3: Funciones
// Demuestra: definición de funciones, parámetros, valores de retorno

// Función simple sin parámetros
fn get_magic_number() -> i32 {
    return 42;
}

// Función con un parámetro
fn double(x: i32) -> i32 {
    return x * 2;
}

// Función con múltiples parámetros
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}

// Función con lógica condicional
fn max(a: i32, b: i32) -> i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

// Función recursiva
fn factorial(n: i32) -> i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// Función principal que usa todas las demás
fn main() -> i32 {
    let magic: i32 = get_magic_number();
    let doubled: i32 = double(magic);
    let sum: i32 = add(doubled, 8);
    let maximum: i32 = max(sum, 100);
    let fact: i32 = factorial(5);
    
    // magic=42, doubled=84, sum=92, maximum=100, fact=120
    return maximum + fact;  // 100 + 120 = 220
}

/*
CONCEPTOS CLAVE:
- Todas las funciones deben especificar tipos de parámetros y retorno
- 'return' es obligatorio (no hay return implícito)
- Las funciones pueden llamarse entre sí
- La recursión está permitida
- No hay función overloading (cada función tiene nombre único)

VENTAJAS DE TEMPO:
- Sin null pointer exceptions
- Sin buffer overflows en los parámetros
- Stack overflow detectado en recursión
- Todas las funciones tienen timing determinístico

PRUEBA:
tempo run 03_functions.tempo
echo $?  # Debe mostrar 220
*/
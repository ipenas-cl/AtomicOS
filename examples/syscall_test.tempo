// Test program for AtomicOS system calls
// Demonstrates deterministic syscall interface

// System call numbers
function SYS_GETPID(): int32 { return 4 }
function SYS_RT_YIELD(): int32 { return 32 }
function SYS_RT_GETTIME(): int32 { return 34 }
function SYS_WRITE(): int32 { return 23 }
function SYS_EXIT(): int32 { return 0 }

// Make a system call with no arguments
function syscall0(number: int32): int32 {
    // In a real Tempo compiler, this would generate:
    // mov eax, number
    // int 0x80
    // return eax
    return 0  // Placeholder
}

// Make a system call with one argument
function syscall1(number: int32, arg0: int32): int32 {
    // mov eax, number
    // mov ebx, arg0
    // int 0x80
    // return eax
    return 0  // Placeholder
}

// Get current process ID
function getpid(): int32 {
    return syscall0(SYS_GETPID())
}

// Yield to scheduler
function yield(): int32 {
    return syscall0(SYS_RT_YIELD())
}

// Get system time in microseconds
function get_time_us(): int32 {
    return syscall0(SYS_RT_GETTIME())
}

// Exit process
function exit(code: int32): int32 {
    return syscall1(SYS_EXIT(), code)
}

// Test syscall functionality
function test_syscalls(): int32 {
    // Test 1: Get PID
    let pid = getpid()
    if (pid <= 0) {
        return 1  // Error
    }
    
    // Test 2: Get time
    let start_time = get_time_us()
    
    // Test 3: Yield
    let yield_result = yield()
    
    // Test 4: Get time again
    let end_time = get_time_us()
    
    // Calculate elapsed time
    let elapsed = end_time - start_time
    
    // Verify time advanced
    if (elapsed <= 0) {
        return 2  // Time didn't advance
    }
    
    return 0  // Success
}

// Main syscall demo
function syscall_demo(): int32 {
    let result = test_syscalls()
    
    if (result != 0) {
        // Exit with error code
        exit(result)
    }
    
    // Exit successfully
    exit(0)
    
    return 0  // Should not reach here
}
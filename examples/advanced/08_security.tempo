// EXAMPLE 8: Programación Segura
// Demuestra: @security_level, capabilities, access control

// Funciones de diferentes niveles de seguridad

@security_level(0)  // Guest level - acceso muy limitado
fn guest_calculate(a: i32, b: i32) -> i32 {
    // Solo operaciones básicas permitidas
    return a + b;
}

@security_level(1)  // User level - operaciones normales
fn user_process_data(data: [10]i32) -> i32 {
    let sum: i32 = 0;
    let i: i32 = 0;
    
    while (i < 10) {
        // Verificación de seguridad: no procesar datos negativos
        if (data[i] >= 0) {
            sum = sum + data[i];
        }
        i = i + 1;
    }
    
    return sum;
}

@security_level(2)  // System level - operaciones privilegiadas
fn system_manage_resource(resource_id: u32, action: i32) -> bool {
    // Verificaciones de sistema
    if (resource_id == 0) {
        return false;  // Resource ID inválido
    }
    
    if (action < 0 || action > 3) {
        return false;  // Acción inválida
    }
    
    // Simular gestión de recurso del sistema
    static resource_table: [100]u32;
    
    if (resource_id < 100) {
        if (action == 1) {
            resource_table[resource_id] = 1;  // Allocate
        } else if (action == 2) {
            resource_table[resource_id] = 0;  // Deallocate
        } else if (action == 3) {
            return resource_table[resource_id] == 1;  // Check status
        }
        return true;
    }
    
    return false;
}

@security_level(3)  // Kernel level - operaciones críticas del sistema
fn kernel_hardware_control(device: u32, command: u64) -> u64 {
    // Solo el kernel puede hacer esto
    
    // Verificaciones críticas
    if (device > 255) {
        return 0xFFFFFFFF;  // Error: device ID muy alto
    }
    
    // Simular acceso directo a hardware
    if (device == 1) {  // Device de red
        if (command == 0x100) {
            return 0x1;  // Network interface up
        } else if (command == 0x200) {
            return 0x2;  // Network interface down
        }
    } else if (device == 2) {  // Device de almacenamiento
        if (command == 0x300) {
            return 0x3;  // Disk ready
        } else if (command == 0x400) {
            return 0x4;  // Disk busy
        }
    }
    
    return 0;  // Success
}

// Función que demuestra la verificación de capabilities
@security_level(1)
fn secure_file_operation(filename_hash: u32, operation: i32) -> i32 {
    // Tabla de permisos simplificada
    static permissions: [10]u32;
    permissions[0] = 0x123;  // Hash del archivo permitido
    permissions[1] = 0x456;
    permissions[2] = 0x789;
    
    // Verificar si el archivo está en la lista de permitidos
    let i: i32 = 0;
    let authorized: bool = false;
    
    while (i < 3) {
        if (permissions[i] == filename_hash) {
            authorized = true;
            break;
        }
        i = i + 1;
    }
    
    if (!authorized) {
        return -1;  // Acceso denegado
    }
    
    // Verificar operación permitida
    if (operation == 1) {  // Read
        return 1;  // Lectura permitida
    } else if (operation == 2) {  // Write
        return 2;  // Escritura permitida
    } else {
        return -2;  // Operación no permitida
    }
}

// Función de auditoría de seguridad
@security_level(2)
fn security_audit_log(user_id: u32, action: u32, resource: u32) -> void {
    // Sistema de auditoría simplificado
    static log_entries: [100]u64;
    static log_count: u32 = 0;
    
    // Crear entrada de log
    let timestamp: u64 = 1234567890;  // Timestamp simulado
    let log_entry: u64 = (timestamp << 32) | 
                        (user_id << 16) | 
                        (action << 8) | 
                        resource;
    
    // Guardar en log circular
    if (log_count < 100) {
        log_entries[log_count] = log_entry;
        log_count = log_count + 1;
    } else {
        // Log está lleno, reemplazar entrada más antigua
        let oldest: u32 = log_count % 100;
        log_entries[oldest] = log_entry;
        log_count = log_count + 1;
    }
}

// Función principal que demuestra escalada de privilegios controlada
fn main() -> i32 {
    let final_score: i32 = 0;
    
    // === OPERACIONES GUEST LEVEL ===
    let guest_result: i32 = guest_calculate(10, 20);
    final_score = final_score + guest_result;  // +30
    
    // === OPERACIONES USER LEVEL ===
    let user_data: [10]i32;
    user_data[0] = 5; user_data[1] = 10; user_data[2] = -3;
    user_data[3] = 8; user_data[4] = 12; user_data[5] = 0;
    user_data[6] = 7; user_data[7] = -1; user_data[8] = 9;
    user_data[9] = 6;
    
    let user_result: i32 = user_process_data(user_data);
    final_score = final_score + user_result;  // +57 (suma solo positivos)
    
    // Operación de archivo segura
    let file_access: i32 = secure_file_operation(0x123, 1);  // Read autorizado
    if (file_access > 0) {
        final_score = final_score + 10;  // +10
    }
    
    // === OPERACIONES SYSTEM LEVEL ===
    let resource_allocated: bool = system_manage_resource(5, 1);  // Allocate
    if (resource_allocated) {
        final_score = final_score + 25;  // +25
    }
    
    let resource_status: bool = system_manage_resource(5, 3);  // Check
    if (resource_status) {
        final_score = final_score + 15;  // +15
    }
    
    // Log de auditoría
    security_audit_log(1001, 42, 5);
    final_score = final_score + 5;  // +5 por logging exitoso
    
    // === OPERACIONES KERNEL LEVEL ===
    let hw_result: u64 = kernel_hardware_control(1, 0x100);  // Network up
    if (hw_result == 1) {
        final_score = final_score + 50;  // +50
    }
    
    let storage_result: u64 = kernel_hardware_control(2, 0x300);  // Disk ready
    if (storage_result == 3) {
        final_score = final_score + 30;  // +30
    }
    
    return final_score;  // 30+57+10+25+15+5+50+30 = 222
}

/*
SEGURIDAD EN TEMPO:

1. SECURITY LEVELS:
   - Level 0 (Guest): Mínimos privilegios
   - Level 1 (User): Operaciones normales de usuario
   - Level 2 (System): Operaciones privilegiadas del sistema
   - Level 3 (Kernel): Control total del hardware

2. CARACTERÍSTICAS:
   - Verificación en compile-time y runtime
   - No hay privilege escalation accidental
   - Access control automático
   - Audit trail built-in

3. CAPABILITIES:
   - Fine-grained permissions
   - Principle of least privilege
   - No ambient authority
   - Revocable permissions

4. MEMORY SAFETY:
   - No buffer overflows
   - No use-after-free
   - No double-free
   - Bounds checking automático

5. CRYPTO SUPPORT:
   - Constant-time operations
   - Side-channel resistance
   - Secure random numbers
   - Verified implementations

VENTAJAS vs SISTEMAS TRADICIONALES:
- C/C++: Manual security, muchos bugs
- Java/.NET: Sandbox pero no RT
- Rust: Memory safe pero no security levels
- Tempo: Security + Memory safety + RT

APLICACIONES:
- Operating system kernels
- Cryptographic libraries
- Network security appliances
- Banking software
- Military/aerospace systems

ATAQUES PREVENIDOS:
- Buffer overflow attacks
- Use-after-free exploits
- Integer overflow attacks
- Time-of-check-time-of-use
- Privilege escalation
- Side-channel attacks

PRUEBA:
tempo run 08_security.tempo
echo $?  # Debe mostrar 222

NOTA: En un sistema real, @security_level sería
enforced por hardware (MMU, security coprocessor).
*/
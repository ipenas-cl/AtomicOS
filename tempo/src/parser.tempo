// Parser module - Self-hosted Tempo compiler
module tempo::parser;

import core;
use core::{malloc, free};
import io;
import tempo::lexer;
use tempo::lexer::{Lexer, Token, TokenType, lexer_next_token};
import tempo::ast;
use tempo::ast::*;

// Parser state
export struct Parser {
    lexer: ptr<Lexer>,
    current_token: Token,
    peek_token: Token,
    errors: ptr<ParseError>,
    error_count: int32
}

// Parse error
export struct ParseError {
    message: array<char, 256>,
    line: int32,
    column: int32,
    next: ptr<ParseError>
}

// Create new parser
@wcet(200)
export function parser_new(lexer: ptr<Lexer>) -> ptr<Parser> {
    let parser = malloc(sizeof(Parser)) as ptr<Parser>;
    parser->lexer = lexer;
    parser->errors = null;
    parser->error_count = 0;
    
    // Read first two tokens
    parser->current_token = lexer_next_token(lexer);
    parser->peek_token = lexer_next_token(lexer);
    
    return parser;
}

// Advance to next token
@wcet(100)
function advance(parser: ptr<Parser>) -> void {
    parser->current_token = parser->peek_token;
    parser->peek_token = lexer_next_token(parser->lexer);
}

// Check current token type
@wcet(10)
function check(parser: ptr<Parser>, type: TokenType) -> bool {
    return parser->current_token.type == type;
}

// Check peek token type
@wcet(10)
function check_peek(parser: ptr<Parser>, type: TokenType) -> bool {
    return parser->peek_token.type == type;
}

// Expect and consume token
@wcet(150)
function expect(parser: ptr<Parser>, type: TokenType, message: ptr<char>) -> bool {
    if check(parser, type) {
        advance(parser);
        return true;
    }
    
    add_error(parser, message);
    return false;
}

// Add parse error
@wcet(200)
function add_error(parser: ptr<Parser>, message: ptr<char>) -> void {
    let error = malloc(sizeof(ParseError)) as ptr<ParseError>;
    
    // Copy message
    let i = 0;
    while message[i] != 0 && i < 255 {
        error->message[i] = message[i];
        i = i + 1;
    }
    error->message[i] = 0;
    
    error->line = parser->current_token.line;
    error->column = parser->current_token.column;
    error->next = parser->errors;
    parser->errors = error;
    parser->error_count = parser->error_count + 1;
}

// Parse program
@wcet(5000)
export function parse_program(parser: ptr<Parser>) -> ptr<ASTNode> {
    let program = create_program_node();
    
    // Parse module declaration
    if check(parser, TokenType::TOK_MODULE) {
        let module_node = parse_module_declaration(parser);
        match program->data {
            ASTNodeData::Program { modules, ... } => {
                add_to_list(&modules, module_node);
            },
            _ => {}
        }
    }
    
    // Parse imports
    while check(parser, TokenType::TOK_IMPORT) {
        let import_node = parse_import(parser);
        match program->data {
            ASTNodeData::Program { imports, ... } => {
                add_to_list(&imports, import_node);
            },
            _ => {}
        }
    }
    
    // Parse top-level declarations
    while !check(parser, TokenType::TOK_EOF) {
        let decl = parse_top_level_declaration(parser);
        if decl != null {
            match program->data {
                ASTNodeData::Program { declarations, ... } => {
                    add_to_list(&declarations, decl);
                },
                _ => {}
            }
        }
    }
    
    return program;
}

// Parse module declaration
@wcet(300)
function parse_module_declaration(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'module'
    
    let node = create_node(ASTNodeType::AST_MODULE);
    let module_name: array<char, 256> = [0; 256];
    
    if check(parser, TokenType::TOK_IDENTIFIER) {
        // Copy module name
        let i = 0;
        while parser->current_token.value[i] != 0 && i < 255 {
            module_name[i] = parser->current_token.value[i];
            i = i + 1;
        }
        advance(parser);
        
        // Handle hierarchical names (e.g., tempo::parser)
        while check(parser, TokenType::TOK_DOUBLE_COLON) {
            advance(parser);
            module_name[i] = ':';
            i = i + 1;
            module_name[i] = ':';
            i = i + 1;
            
            if check(parser, TokenType::TOK_IDENTIFIER) {
                let j = 0;
                while parser->current_token.value[j] != 0 && i < 255 {
                    module_name[i] = parser->current_token.value[j];
                    i = i + 1;
                    j = j + 1;
                }
                advance(parser);
            }
        }
    }
    
    expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after module declaration");
    
    node->data = ASTNodeData::Module { name: module_name };
    return node;
}

// Parse import statement
@wcet(500)
function parse_import(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'import'
    
    let node = create_node(ASTNodeType::AST_IMPORT);
    let import_data = ASTNodeData::Import {
        module_name: [0; 256],
        alias: [0; 256],
        symbols: null
    };
    
    // Parse module name
    if check(parser, TokenType::TOK_IDENTIFIER) {
        let i = 0;
        while parser->current_token.value[i] != 0 && i < 255 {
            match import_data {
                ASTNodeData::Import { module_name, ... } => {
                    module_name[i] = parser->current_token.value[i];
                },
                _ => {}
            }
            i = i + 1;
        }
        advance(parser);
        
        // Handle hierarchical names
        while check(parser, TokenType::TOK_DOUBLE_COLON) {
            advance(parser);
            match import_data {
                ASTNodeData::Import { module_name, ... } => {
                    module_name[i] = ':';
                    i = i + 1;
                    module_name[i] = ':';
                    i = i + 1;
                },
                _ => {}
            }
            
            if check(parser, TokenType::TOK_IDENTIFIER) {
                let j = 0;
                while parser->current_token.value[j] != 0 && i < 255 {
                    match import_data {
                        ASTNodeData::Import { module_name, ... } => {
                            module_name[i] = parser->current_token.value[j];
                        },
                        _ => {}
                    }
                    i = i + 1;
                    j = j + 1;
                }
                advance(parser);
            }
        }
    }
    
    // Parse optional alias
    if check(parser, TokenType::TOK_AS) {
        advance(parser);
        if check(parser, TokenType::TOK_IDENTIFIER) {
            let i = 0;
            while parser->current_token.value[i] != 0 && i < 255 {
                match import_data {
                    ASTNodeData::Import { alias, ... } => {
                        alias[i] = parser->current_token.value[i];
                    },
                    _ => {}
                }
                i = i + 1;
            }
            advance(parser);
        }
    }
    
    expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after import");
    
    node->data = import_data;
    return node;
}

// Parse top-level declaration
@wcet(1000)
function parse_top_level_declaration(parser: ptr<Parser>) -> ptr<ASTNode> {
    // Check for export
    let is_export = false;
    if check(parser, TokenType::TOK_EXPORT) {
        is_export = true;
        advance(parser);
    }
    
    // Check for annotations
    let annotations: ptr<ASTNode> = null;
    while check(parser, TokenType::TOK_AT) {
        let ann = parse_annotation(parser);
        add_to_list(&annotations, ann);
    }
    
    let node: ptr<ASTNode> = null;
    
    if check(parser, TokenType::TOK_FUNCTION) {
        node = parse_function(parser);
        match node->data {
            ASTNodeData::Function { annotations: ann, is_export: exp, ... } => {
                ann = annotations;
                exp = is_export;
            },
            _ => {}
        }
    } else if check(parser, TokenType::TOK_STRUCT) {
        node = parse_struct(parser);
        match node->data {
            ASTNodeData::Struct { is_export: exp, ... } => {
                exp = is_export;
            },
            _ => {}
        }
    } else if check(parser, TokenType::TOK_ENUM) {
        node = parse_enum(parser);
        match node->data {
            ASTNodeData::Enum { is_export: exp, ... } => {
                exp = is_export;
            },
            _ => {}
        }
    } else if check(parser, TokenType::TOK_TYPE) {
        node = parse_type_alias(parser);
    } else if check(parser, TokenType::TOK_CONST) {
        node = parse_constant(parser);
    } else if check(parser, TokenType::TOK_STATIC) {
        node = parse_static_variable(parser);
    } else {
        add_error(parser, "Expected declaration");
        advance(parser);
    }
    
    return node;
}

// Parse annotation
@wcet(300)
function parse_annotation(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip '@'
    
    let node = create_node(ASTNodeType::AST_ANNOTATION);
    let ann_data = ASTNodeData::Annotation {
        name: [0; 256],
        args: null
    };
    
    // Get annotation name
    if check(parser, TokenType::TOK_IDENTIFIER) ||
        check(parser, TokenType::TOK_WCET) ||
        check(parser, TokenType::TOK_SECURITY) ||
        check(parser, TokenType::TOK_DETERMINISTIC) ||
        check(parser, TokenType::TOK_CONSTANT_TIME) {
        let i = 0;
        while parser->current_token.value[i] != 0 && i < 255 {
            match ann_data {
                ASTNodeData::Annotation { name, ... } => {
                    name[i] = parser->current_token.value[i];
                },
                _ => {}
            }
            i = i + 1;
        }
        advance(parser);
    }
    
    // Parse arguments if present
    if check(parser, TokenType::TOK_LPAREN) {
        advance(parser);
        
        while !check(parser, TokenType::TOK_RPAREN) && !check(parser, TokenType::TOK_EOF) {
            let arg = parse_expression(parser);
            match ann_data {
                ASTNodeData::Annotation { args, ... } => {
                    add_to_list(&args, arg);
                },
                _ => {}
            }
            
            if check(parser, TokenType::TOK_COMMA) {
                advance(parser);
            }
        }
        
        expect(parser, TokenType::TOK_RPAREN, "Expected ')' after annotation arguments");
    }
    
    node->data = ann_data;
    return node;
}

// Parse function
@wcet(1500)
function parse_function(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'function'
    
    let name: array<char, 256> = [0; 256];
    
    // Get function name
    if check(parser, TokenType::TOK_IDENTIFIER) {
        let i = 0;
        while parser->current_token.value[i] != 0 && i < 255 {
            name[i] = parser->current_token.value[i];
            i = i + 1;
        }
        advance(parser);
    }
    
    // Parse generic parameters if present
    let generics: ptr<ASTNode> = null;
    if check(parser, TokenType::TOK_LT) {
        // TODO: Parse generics
        skip_until(parser, TokenType::TOK_GT);
        advance(parser);
    }
    
    // Parse parameters
    expect(parser, TokenType::TOK_LPAREN, "Expected '(' after function name");
    let params: ptr<ASTNode> = null;
    
    while !check(parser, TokenType::TOK_RPAREN) && !check(parser, TokenType::TOK_EOF) {
        let param = parse_parameter(parser);
        add_to_list(&params, param);
        
        if check(parser, TokenType::TOK_COMMA) {
            advance(parser);
        }
    }
    
    expect(parser, TokenType::TOK_RPAREN, "Expected ')' after parameters");
    
    // Parse return type
    let return_type: ptr<ASTNode> = null;
    if check(parser, TokenType::TOK_ARROW) {
        advance(parser);
        return_type = parse_type(parser);
    }
    
    // Parse body
    let body: ptr<ASTNode> = null;
    if check(parser, TokenType::TOK_LBRACE) {
        body = parse_block(parser);
    } else {
        expect(parser, TokenType::TOK_SEMICOLON, "Expected '{' or ';' after function declaration");
    }
    
    return create_function_node(name as ptr<char>, params, return_type, body);
}

// Parse parameter
@wcet(400)
function parse_parameter(parser: ptr<Parser>) -> ptr<ASTNode> {
    let node = create_node(ASTNodeType::AST_VARIABLE);
    let var_data = ASTNodeData::Variable {
        name: [0; 256],
        var_type: null,
        init_expr: null,
        is_const: false,
        is_static: false
    };
    
    // Get parameter name
    if check(parser, TokenType::TOK_IDENTIFIER) {
        let i = 0;
        while parser->current_token.value[i] != 0 && i < 255 {
            match var_data {
                ASTNodeData::Variable { name, ... } => {
                    name[i] = parser->current_token.value[i];
                },
                _ => {}
            }
            i = i + 1;
        }
        advance(parser);
    }
    
    expect(parser, TokenType::TOK_COLON, "Expected ':' after parameter name");
    
    // Parse type
    match var_data {
        ASTNodeData::Variable { var_type, ... } => {
            var_type = parse_type(parser);
        },
        _ => {}
    }
    
    node->data = var_data;
    return node;
}

// Parse type
@wcet(800)
function parse_type(parser: ptr<Parser>) -> ptr<ASTNode> {
    let node = create_node(ASTNodeType::AST_TYPE);
    
    // Check for pointer type
    if check(parser, TokenType::TOK_PTR) {
        advance(parser);
        expect(parser, TokenType::TOK_LT, "Expected '<' after 'ptr'");
        let pointee = parse_type(parser);
        expect(parser, TokenType::TOK_GT, "Expected '>' after pointer type");
        
        // Create pointer type
        // TODO: Implement proper type creation
        return node;
    }
    
    // Check for array type
    if check(parser, TokenType::TOK_ARRAY) {
        advance(parser);
        expect(parser, TokenType::TOK_LT, "Expected '<' after 'array'");
        let element = parse_type(parser);
        expect(parser, TokenType::TOK_COMMA, "Expected ',' in array type");
        let size = parse_expression(parser);
        expect(parser, TokenType::TOK_GT, "Expected '>' after array type");
        
        // Create array type
        // TODO: Implement proper type creation
        return node;
    }
    
    // Basic types
    if check(parser, TokenType::TOK_VOID) ||
        check(parser, TokenType::TOK_BOOL) ||
        check(parser, TokenType::TOK_INT8) ||
        check(parser, TokenType::TOK_INT16) ||
        check(parser, TokenType::TOK_INT32) ||
        check(parser, TokenType::TOK_INT64) ||
        check(parser, TokenType::TOK_UINT8) ||
        check(parser, TokenType::TOK_UINT16) ||
        check(parser, TokenType::TOK_UINT32) ||
        check(parser, TokenType::TOK_UINT64) ||
        check(parser, TokenType::TOK_FLOAT32) ||
        check(parser, TokenType::TOK_FLOAT64) ||
        check(parser, TokenType::TOK_CHAR_TYPE) {
        advance(parser);
        return node;
    }
    
    // User-defined types
    if check(parser, TokenType::TOK_IDENTIFIER) {
        advance(parser);
        return node;
    }
    
    add_error(parser, "Expected type");
    return node;
}

// Parse block statement
@wcet(2000)
function parse_block(parser: ptr<Parser>) -> ptr<ASTNode> {
    expect(parser, TokenType::TOK_LBRACE, "Expected '{'");
    
    let node = create_node(ASTNodeType::AST_BLOCK);
    let block_data = ASTNodeData::Block {
        statements: null
    };
    
    while !check(parser, TokenType::TOK_RBRACE) && !check(parser, TokenType::TOK_EOF) {
        let stmt = parse_statement(parser);
        if stmt != null {
            match block_data {
                ASTNodeData::Block { statements } => {
                    add_to_list(&statements, stmt);
                },
                _ => {}
            }
        }
    }
    
    expect(parser, TokenType::TOK_RBRACE, "Expected '}'");
    
    node->data = block_data;
    return node;
}

// Parse statement
@wcet(1500)
function parse_statement(parser: ptr<Parser>) -> ptr<ASTNode> {
    if check(parser, TokenType::TOK_RETURN) {
        return parse_return_statement(parser);
    } else if check(parser, TokenType::TOK_IF) {
        return parse_if_statement(parser);
    } else if check(parser, TokenType::TOK_WHILE) {
        return parse_while_statement(parser);
    } else if check(parser, TokenType::TOK_FOR) {
        return parse_for_statement(parser);
    } else if check(parser, TokenType::TOK_MATCH) {
        return parse_match_statement(parser);
    } else if check(parser, TokenType::TOK_LET) {
        return parse_let_statement(parser);
    } else if check(parser, TokenType::TOK_LBRACE) {
        return parse_block(parser);
    } else if check(parser, TokenType::TOK_BREAK) {
        advance(parser);
        expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after 'break'");
        return create_node(ASTNodeType::AST_BREAK);
    } else if check(parser, TokenType::TOK_CONTINUE) {
        advance(parser);
        expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after 'continue'");
        return create_node(ASTNodeType::AST_CONTINUE);
    } else {
        // Expression statement
        let expr = parse_expression(parser);
        expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after expression");
        
        let node = create_node(ASTNodeType::AST_EXPRESSION_STMT);
        node->data = ASTNodeData::Return { expr: expr };  // Reusing Return data
        return node;
    }
}

// Parse return statement
@wcet(300)
function parse_return_statement(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'return'
    
    let node = create_node(ASTNodeType::AST_RETURN);
    let expr: ptr<ASTNode> = null;
    
    if !check(parser, TokenType::TOK_SEMICOLON) {
        expr = parse_expression(parser);
    }
    
    expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after return");
    
    node->data = ASTNodeData::Return { expr: expr };
    return node;
}

// Parse let statement
@wcet(500)
function parse_let_statement(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'let'
    
    let node = create_node(ASTNodeType::AST_VARIABLE);
    let var_data = ASTNodeData::Variable {
        name: [0; 256],
        var_type: null,
        init_expr: null,
        is_const: false,
        is_static: false
    };
    
    // Get variable name
    if check(parser, TokenType::TOK_IDENTIFIER) {
        let i = 0;
        while parser->current_token.value[i] != 0 && i < 255 {
            match var_data {
                ASTNodeData::Variable { name, ... } => {
                    name[i] = parser->current_token.value[i];
                },
                _ => {}
            }
            i = i + 1;
        }
        advance(parser);
    }
    
    // Optional type annotation
    if check(parser, TokenType::TOK_COLON) {
        advance(parser);
        match var_data {
            ASTNodeData::Variable { var_type, ... } => {
                var_type = parse_type(parser);
            },
            _ => {}
        }
    }
    
    // Optional initialization
    if check(parser, TokenType::TOK_ASSIGN) {
        advance(parser);
        match var_data {
            ASTNodeData::Variable { init_expr, ... } => {
                init_expr = parse_expression(parser);
            },
            _ => {}
        }
    }
    
    expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after variable declaration");
    
    node->data = var_data;
    return node;
}

// Parse expression
@wcet(2000)
function parse_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    return parse_assignment_expression(parser);
}

// Parse assignment expression
@wcet(500)
function parse_assignment_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    let left = parse_logical_or_expression(parser);
    
    if check(parser, TokenType::TOK_ASSIGN) {
        advance(parser);
        let right = parse_assignment_expression(parser);
        
        let node = create_node(ASTNodeType::AST_ASSIGNMENT);
        node->data = ASTNodeData::Assignment {
            target: left,
            value: right
        };
        return node;
    }
    
    return left;
}

// Parse logical OR expression
@wcet(500)
function parse_logical_or_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    let left = parse_logical_and_expression(parser);
    
    while check(parser, TokenType::TOK_OR) {
        advance(parser);
        let right = parse_logical_and_expression(parser);
        left = create_binary_op_node(BinaryOp::OP_OR, left, right);
    }
    
    return left;
}

// Parse logical AND expression
@wcet(500)
function parse_logical_and_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    let left = parse_equality_expression(parser);
    
    while check(parser, TokenType::TOK_AND) {
        advance(parser);
        let right = parse_equality_expression(parser);
        left = create_binary_op_node(BinaryOp::OP_AND, left, right);
    }
    
    return left;
}

// Parse equality expression
@wcet(500)
function parse_equality_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    let left = parse_relational_expression(parser);
    
    while check(parser, TokenType::TOK_EQ) || check(parser, TokenType::TOK_NE) {
        let op = if check(parser, TokenType::TOK_EQ) { 
            BinaryOp::OP_EQ 
        } else { 
            BinaryOp::OP_NE 
        };
        advance(parser);
        let right = parse_relational_expression(parser);
        left = create_binary_op_node(op, left, right);
    }
    
    return left;
}

// Parse relational expression
@wcet(500)
function parse_relational_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    let left = parse_additive_expression(parser);
    
    while check(parser, TokenType::TOK_LT) || 
          check(parser, TokenType::TOK_GT) ||
          check(parser, TokenType::TOK_LE) || 
          check(parser, TokenType::TOK_GE) {
        let op = BinaryOp::OP_LT;
        if check(parser, TokenType::TOK_GT) {
            op = BinaryOp::OP_GT;
        } else if check(parser, TokenType::TOK_LE) {
            op = BinaryOp::OP_LE;
        } else if check(parser, TokenType::TOK_GE) {
            op = BinaryOp::OP_GE;
        }
        advance(parser);
        let right = parse_additive_expression(parser);
        left = create_binary_op_node(op, left, right);
    }
    
    return left;
}

// Parse additive expression
@wcet(500)
function parse_additive_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    let left = parse_multiplicative_expression(parser);
    
    while check(parser, TokenType::TOK_PLUS) || check(parser, TokenType::TOK_MINUS) {
        let op = if check(parser, TokenType::TOK_PLUS) { 
            BinaryOp::OP_ADD 
        } else { 
            BinaryOp::OP_SUB 
        };
        advance(parser);
        let right = parse_multiplicative_expression(parser);
        left = create_binary_op_node(op, left, right);
    }
    
    return left;
}

// Parse multiplicative expression
@wcet(500)
function parse_multiplicative_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    let left = parse_unary_expression(parser);
    
    while check(parser, TokenType::TOK_STAR) || 
          check(parser, TokenType::TOK_SLASH) || 
          check(parser, TokenType::TOK_PERCENT) {
        let op = BinaryOp::OP_MUL;
        if check(parser, TokenType::TOK_SLASH) {
            op = BinaryOp::OP_DIV;
        } else if check(parser, TokenType::TOK_PERCENT) {
            op = BinaryOp::OP_MOD;
        }
        advance(parser);
        let right = parse_unary_expression(parser);
        left = create_binary_op_node(op, left, right);
    }
    
    return left;
}

// Parse unary expression
@wcet(400)
function parse_unary_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    if check(parser, TokenType::TOK_MINUS) {
        advance(parser);
        let operand = parse_unary_expression(parser);
        let node = create_node(ASTNodeType::AST_UNARY_OP);
        node->data = ASTNodeData::UnaryOp {
            op: UnaryOp::OP_NEG,
            operand: operand
        };
        return node;
    }
    
    if check(parser, TokenType::TOK_NOT) {
        advance(parser);
        let operand = parse_unary_expression(parser);
        let node = create_node(ASTNodeType::AST_UNARY_OP);
        node->data = ASTNodeData::UnaryOp {
            op: UnaryOp::OP_NOT,
            operand: operand
        };
        return node;
    }
    
    if check(parser, TokenType::TOK_STAR) {
        advance(parser);
        let operand = parse_unary_expression(parser);
        let node = create_node(ASTNodeType::AST_UNARY_OP);
        node->data = ASTNodeData::UnaryOp {
            op: UnaryOp::OP_DEREF,
            operand: operand
        };
        return node;
    }
    
    if check(parser, TokenType::TOK_AMPERSAND) {
        advance(parser);
        let operand = parse_unary_expression(parser);
        let node = create_node(ASTNodeType::AST_UNARY_OP);
        node->data = ASTNodeData::UnaryOp {
            op: UnaryOp::OP_ADDR,
            operand: operand
        };
        return node;
    }
    
    return parse_postfix_expression(parser);
}

// Parse postfix expression
@wcet(800)
function parse_postfix_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    let left = parse_primary_expression(parser);
    
    while true {
        if check(parser, TokenType::TOK_LPAREN) {
            // Function call
            advance(parser);
            let args: ptr<ASTNode> = null;
            
            while !check(parser, TokenType::TOK_RPAREN) && !check(parser, TokenType::TOK_EOF) {
                let arg = parse_expression(parser);
                add_to_list(&args, arg);
                
                if check(parser, TokenType::TOK_COMMA) {
                    advance(parser);
                }
            }
            
            expect(parser, TokenType::TOK_RPAREN, "Expected ')' after arguments");
            
            let node = create_node(ASTNodeType::AST_CALL);
            node->data = ASTNodeData::Call {
                func: left,
                args: args
            };
            left = node;
        } else if check(parser, TokenType::TOK_DOT) {
            // Field access
            advance(parser);
            
            let field_name: array<char, 256> = [0; 256];
            if check(parser, TokenType::TOK_IDENTIFIER) {
                let i = 0;
                while parser->current_token.value[i] != 0 && i < 255 {
                    field_name[i] = parser->current_token.value[i];
                    i = i + 1;
                }
                advance(parser);
            }
            
            let node = create_node(ASTNodeType::AST_FIELD_ACCESS);
            node->data = ASTNodeData::FieldAccess {
                object: left,
                field: field_name
            };
            left = node;
        } else if check(parser, TokenType::TOK_LBRACKET) {
            // Array index
            advance(parser);
            let index = parse_expression(parser);
            expect(parser, TokenType::TOK_RBRACKET, "Expected ']' after index");
            
            let node = create_node(ASTNodeType::AST_INDEX);
            node->data = ASTNodeData::Index {
                array: left,
                index: index
            };
            left = node;
        } else if check(parser, TokenType::TOK_AS) {
            // Type cast
            advance(parser);
            let target_type = parse_type(parser);
            
            let node = create_node(ASTNodeType::AST_CAST);
            node->data = ASTNodeData::Cast {
                expr: left,
                target_type: target_type
            };
            left = node;
        } else {
            break;
        }
    }
    
    return left;
}

// Parse primary expression
@wcet(800)
function parse_primary_expression(parser: ptr<Parser>) -> ptr<ASTNode> {
    if check(parser, TokenType::TOK_INTEGER) {
        let value = parser->current_token.int_value;
        advance(parser);
        return create_integer_literal_node(value);
    }
    
    if check(parser, TokenType::TOK_FLOAT) {
        let node = create_node(ASTNodeType::AST_FLOAT_LITERAL);
        node->data = ASTNodeData::FloatLiteral {
            value: parser->current_token.float_value
        };
        advance(parser);
        return node;
    }
    
    if check(parser, TokenType::TOK_STRING) {
        let node = create_node(ASTNodeType::AST_STRING_LITERAL);
        let str_data = ASTNodeData::StringLiteral {
            value: [0; 256]
        };
        
        // Copy string value
        let i = 0;
        while parser->current_token.value[i] != 0 && i < 255 {
            match str_data {
                ASTNodeData::StringLiteral { value } => {
                    value[i] = parser->current_token.value[i];
                },
                _ => {}
            }
            i = i + 1;
        }
        
        node->data = str_data;
        advance(parser);
        return node;
    }
    
    if check(parser, TokenType::TOK_CHAR) {
        let node = create_node(ASTNodeType::AST_CHAR_LITERAL);
        node->data = ASTNodeData::CharLiteral {
            value: parser->current_token.value[0]
        };
        advance(parser);
        return node;
    }
    
    if check(parser, TokenType::TOK_TRUE) {
        let node = create_node(ASTNodeType::AST_BOOL_LITERAL);
        node->data = ASTNodeData::BoolLiteral { value: true };
        advance(parser);
        return node;
    }
    
    if check(parser, TokenType::TOK_FALSE) {
        let node = create_node(ASTNodeType::AST_BOOL_LITERAL);
        node->data = ASTNodeData::BoolLiteral { value: false };
        advance(parser);
        return node;
    }
    
    if check(parser, TokenType::TOK_NULL) {
        advance(parser);
        return create_node(ASTNodeType::AST_NULL_LITERAL);
    }
    
    if check(parser, TokenType::TOK_IDENTIFIER) {
        let name = parser->current_token.value;
        advance(parser);
        return create_identifier_node(name as ptr<char>);
    }
    
    if check(parser, TokenType::TOK_LPAREN) {
        advance(parser);
        let expr = parse_expression(parser);
        expect(parser, TokenType::TOK_RPAREN, "Expected ')' after expression");
        return expr;
    }
    
    if check(parser, TokenType::TOK_LBRACKET) {
        // Array literal
        advance(parser);
        let node = create_node(ASTNodeType::AST_ARRAY_LITERAL);
        let elements: ptr<ASTNode> = null;
        
        while !check(parser, TokenType::TOK_RBRACKET) && !check(parser, TokenType::TOK_EOF) {
            let elem = parse_expression(parser);
            add_to_list(&elements, elem);
            
            if check(parser, TokenType::TOK_COMMA) {
                advance(parser);
            }
        }
        
        expect(parser, TokenType::TOK_RBRACKET, "Expected ']' after array elements");
        
        node->data = ASTNodeData::ArrayLiteral { elements: elements };
        return node;
    }
    
    add_error(parser, "Expected expression");
    return create_node(ASTNodeType::AST_ERROR);
}

// Helper functions
@wcet(300)
function skip_until(parser: ptr<Parser>, type: TokenType) -> void {
    while !check(parser, type) && !check(parser, TokenType::TOK_EOF) {
        advance(parser);
    }
}

// Stub functions for unimplemented features
@wcet(500)
function parse_if_statement(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'if'
    
    expect(parser, TokenType::TOK_LPAREN, "Expected '(' after 'if'");
    let condition = parse_expression(parser);
    expect(parser, TokenType::TOK_RPAREN, "Expected ')' after condition");
    
    let then_stmt = parse_statement(parser);
    let else_stmt: ptr<ASTNode> = null;
    
    if check(parser, TokenType::TOK_ELSE) {
        advance(parser);
        else_stmt = parse_statement(parser);
    }
    
    let node = create_node(ASTNodeType::AST_IF);
    node->data = ASTNodeData::If {
        condition: condition,
        then_stmt: then_stmt,
        else_stmt: else_stmt
    };
    return node;
}

@wcet(500)
function parse_while_statement(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'while'
    
    expect(parser, TokenType::TOK_LPAREN, "Expected '(' after 'while'");
    let condition = parse_expression(parser);
    expect(parser, TokenType::TOK_RPAREN, "Expected ')' after condition");
    
    let body = parse_statement(parser);
    
    let node = create_node(ASTNodeType::AST_WHILE);
    node->data = ASTNodeData::While {
        condition: condition,
        body: body
    };
    return node;
}

@wcet(800)
function parse_for_statement(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'for'
    
    expect(parser, TokenType::TOK_LPAREN, "Expected '(' after 'for'");
    
    let init: ptr<ASTNode> = null;
    if !check(parser, TokenType::TOK_SEMICOLON) {
        if check(parser, TokenType::TOK_LET) {
            init = parse_let_statement(parser);
        } else {
            init = parse_expression(parser);
            expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after for init");
        }
    } else {
        advance(parser); // Skip semicolon
    }
    
    let condition: ptr<ASTNode> = null;
    if !check(parser, TokenType::TOK_SEMICOLON) {
        condition = parse_expression(parser);
    }
    expect(parser, TokenType::TOK_SEMICOLON, "Expected ';' after for condition");
    
    let update: ptr<ASTNode> = null;
    if !check(parser, TokenType::TOK_RPAREN) {
        update = parse_expression(parser);
    }
    expect(parser, TokenType::TOK_RPAREN, "Expected ')' after for clauses");
    
    let body = parse_statement(parser);
    
    let node = create_node(ASTNodeType::AST_FOR);
    node->data = ASTNodeData::For {
        init: init,
        condition: condition,
        update: update,
        body: body
    };
    return node;
}

@wcet(1000)
function parse_match_statement(parser: ptr<Parser>) -> ptr<ASTNode> {
    advance(parser); // Skip 'match'
    
    let expr = parse_expression(parser);
    expect(parser, TokenType::TOK_LBRACE, "Expected '{' after match expression");
    
    let arms: ptr<ASTNode> = null;
    
    while !check(parser, TokenType::TOK_RBRACE) && !check(parser, TokenType::TOK_EOF) {
        // TODO: Parse match pattern
        let pattern = parse_expression(parser);
        
        expect(parser, TokenType::TOK_ARROW, "Expected '=>' in match arm");
        
        let body = if check(parser, TokenType::TOK_LBRACE) {
            parse_block(parser)
        } else {
            parse_expression(parser)
        };
        
        if check(parser, TokenType::TOK_COMMA) {
            advance(parser);
        }
        
        let arm = create_node(ASTNodeType::AST_MATCH_ARM);
        arm->data = ASTNodeData::MatchArm {
            pattern: pattern,
            guard: null,
            body: body
        };
        add_to_list(&arms, arm);
    }
    
    expect(parser, TokenType::TOK_RBRACE, "Expected '}' after match arms");
    
    let node = create_node(ASTNodeType::AST_MATCH);
    node->data = ASTNodeData::Match {
        expr: expr,
        arms: arms
    };
    return node;
}

@wcet(300)
function parse_struct(parser: ptr<Parser>) -> ptr<ASTNode> {
    // TODO: Implement struct parsing
    advance(parser);
    return create_node(ASTNodeType::AST_STRUCT);
}

@wcet(300)
function parse_enum(parser: ptr<Parser>) -> ptr<ASTNode> {
    // TODO: Implement enum parsing
    advance(parser);
    return create_node(ASTNodeType::AST_ENUM);
}

@wcet(300)
function parse_type_alias(parser: ptr<Parser>) -> ptr<ASTNode> {
    // TODO: Implement type alias parsing
    advance(parser);
    return create_node(ASTNodeType::AST_TYPE_ALIAS);
}

@wcet(300)
function parse_constant(parser: ptr<Parser>) -> ptr<ASTNode> {
    // TODO: Implement constant parsing
    advance(parser);
    return create_node(ASTNodeType::AST_CONSTANT);
}

@wcet(300)
function parse_static_variable(parser: ptr<Parser>) -> ptr<ASTNode> {
    // TODO: Implement static variable parsing
    advance(parser);
    return create_node(ASTNodeType::AST_VARIABLE);
}

// Test parser
@wcet(10000)
export function test_parser() -> void {
    let test_code = "
module test;

import io;

@wcet(100)
export function add(a: int32, b: int32) -> int32 {
    return a + b;
}

function main() -> void {
    let x = 10;
    let y = 20;
    let sum = add(x, y);
    io::print_int(sum);
}
";
    
    let lexer = lexer_new(test_code, 300);
    let parser = parser_new(lexer);
    
    io::println("Parser Test:");
    
    let ast = parse_program(parser);
    
    if parser->error_count > 0 {
        io::print("Parse errors: ");
        io::print_int(parser->error_count);
        io::println("");
        
        let error = parser->errors;
        while error != null {
            io::print("Error at ");
            io::print_int(error->line);
            io::print(":");
            io::print_int(error->column);
            io::print(" - ");
            io::println(error->message as ptr<char>);
            error = error->next;
        }
    } else {
        io::println("Parsing successful!");
        io::println("AST:");
        print_ast(ast, 0);
    }
    
    // Cleanup
    free_ast(ast);
    free(parser as ptr<void>);
    free(lexer as ptr<void>);
}
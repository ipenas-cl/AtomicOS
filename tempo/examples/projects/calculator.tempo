// PROJECT: Calculator
// Una calculadora completa demostrando múltiples conceptos de Tempo
// Incluye: parsing, stack-based evaluation, error handling, user interface

// Estructura para representar tokens
struct Token {
    type: i32,      // Tipo: NUMBER, OPERATOR, PAREN, etc.
    value: i32,     // Valor numérico (para números)
    operator: char  // Operador (para operadores)
}

// Estructura para la stack de evaluación
struct EvalStack {
    data: [100]i32,
    top: i32
}

// Estructura principal de la calculadora
struct Calculator {
    tokens: [50]Token,
    token_count: i32,
    eval_stack: EvalStack,
    error: bool,
    error_code: i32
}

// Constantes para tipos de token
const TOKEN_NUMBER: i32 = 1;
const TOKEN_OPERATOR: i32 = 2;
const TOKEN_LPAREN: i32 = 3;
const TOKEN_RPAREN: i32 = 4;
const TOKEN_END: i32 = 5;

// Códigos de error
const ERROR_NONE: i32 = 0;
const ERROR_INVALID_CHAR: i32 = 1;
const ERROR_STACK_OVERFLOW: i32 = 2;
const ERROR_STACK_UNDERFLOW: i32 = 3;
const ERROR_DIVIDE_BY_ZERO: i32 = 4;
const ERROR_MISMATCHED_PARENS: i32 = 5;

// === FUNCIONES DE STACK ===

@wcet(50)
fn stack_init(stack: *EvalStack) -> void {
    stack->top = -1;
}

@wcet(100)
fn stack_push(stack: *EvalStack, value: i32) -> bool {
    if (stack->top >= 99) {
        return false;  // Stack overflow
    }
    
    stack->top = stack->top + 1;
    stack->data[stack->top] = value;
    return true;
}

@wcet(100)
fn stack_pop(stack: *EvalStack) -> i32 {
    if (stack->top < 0) {
        return 0;  // Stack underflow
    }
    
    let value: i32 = stack->data[stack->top];
    stack->top = stack->top - 1;
    return value;
}

@wcet(50)
fn stack_is_empty(stack: *EvalStack) -> bool {
    return stack->top < 0;
}

@wcet(50)
fn stack_size(stack: *EvalStack) -> i32 {
    return stack->top + 1;
}

// === FUNCIONES DE TOKENIZACIÓN ===

@wcet(100)
fn is_digit(c: char) -> bool {
    return c >= '0' && c <= '9';
}

@wcet(100)
fn is_operator(c: char) -> bool {
    return c == '+' || c == '-' || c == '*' || c == '/';
}

@wcet(300)
fn char_to_number(c: char) -> i32 {
    if (is_digit(c)) {
        return c - '0';
    }
    return -1;  // Error
}

@wcet(500)
fn tokenize_expression(calc: *Calculator, expr: [20]char) -> bool {
    calc->token_count = 0;
    calc->error = false;
    
    let i: i32 = 0;
    
    while (i < 20 && expr[i] != 0) {
        let c: char = expr[i];
        
        // Saltar espacios
        if (c == ' ') {
            i = i + 1;
            continue;
        }
        
        // Verificar si tenemos espacio para más tokens
        if (calc->token_count >= 50) {
            calc->error = true;
            calc->error_code = ERROR_STACK_OVERFLOW;
            return false;
        }
        
        if (is_digit(c)) {
            // Token numérico
            calc->tokens[calc->token_count].type = TOKEN_NUMBER;
            calc->tokens[calc->token_count].value = char_to_number(c);
            calc->tokens[calc->token_count].operator = 0;
        } else if (is_operator(c)) {
            // Token operador
            calc->tokens[calc->token_count].type = TOKEN_OPERATOR;
            calc->tokens[calc->token_count].value = 0;
            calc->tokens[calc->token_count].operator = c;
        } else if (c == '(') {
            // Paréntesis izquierdo
            calc->tokens[calc->token_count].type = TOKEN_LPAREN;
            calc->tokens[calc->token_count].value = 0;
            calc->tokens[calc->token_count].operator = c;
        } else if (c == ')') {
            // Paréntesis derecho
            calc->tokens[calc->token_count].type = TOKEN_RPAREN;
            calc->tokens[calc->token_count].value = 0;
            calc->tokens[calc->token_count].operator = c;
        } else {
            // Carácter inválido
            calc->error = true;
            calc->error_code = ERROR_INVALID_CHAR;
            return false;
        }
        
        calc->token_count = calc->token_count + 1;
        i = i + 1;
    }
    
    return true;
}

// === FUNCIONES DE EVALUACIÓN ===

@wcet(100)
fn get_operator_precedence(op: char) -> i32 {
    if (op == '+' || op == '-') {
        return 1;
    } else if (op == '*' || op == '/') {
        return 2;
    }
    return 0;
}

@wcet(200)
fn apply_operator(a: i32, b: i32, op: char) -> i32 {
    if (op == '+') {
        return a + b;
    } else if (op == '-') {
        return a - b;
    } else if (op == '*') {
        return a * b;
    } else if (op == '/') {
        if (b == 0) {
            return 0;  // División por cero
        }
        return a / b;
    }
    return 0;  // Operador inválido
}

@wcet(1000)
fn evaluate_expression(calc: *Calculator) -> i32 {
    stack_init(&calc->eval_stack);
    let operator_stack: EvalStack;
    stack_init(&operator_stack);
    
    let i: i32 = 0;
    
    while (i < calc->token_count) {
        let token: Token = calc->tokens[i];
        
        if (token.type == TOKEN_NUMBER) {
            // Número: push a stack de valores
            if (!stack_push(&calc->eval_stack, token.value)) {
                calc->error = true;
                calc->error_code = ERROR_STACK_OVERFLOW;
                return 0;
            }
        } else if (token.type == TOKEN_OPERATOR) {
            // Operador: manejar precedencia
            let current_prec: i32 = get_operator_precedence(token.operator);
            
            while (!stack_is_empty(&operator_stack)) {
                let top_op: i32 = operator_stack.data[operator_stack.top];
                let top_prec: i32 = get_operator_precedence(top_op as char);
                
                if (top_prec >= current_prec) {
                    // Aplicar operador de mayor precedencia
                    let op: char = stack_pop(&operator_stack) as char;
                    
                    if (stack_size(&calc->eval_stack) < 2) {
                        calc->error = true;
                        calc->error_code = ERROR_STACK_UNDERFLOW;
                        return 0;
                    }
                    
                    let b: i32 = stack_pop(&calc->eval_stack);
                    let a: i32 = stack_pop(&calc->eval_stack);
                    
                    if (op == '/' && b == 0) {
                        calc->error = true;
                        calc->error_code = ERROR_DIVIDE_BY_ZERO;
                        return 0;
                    }
                    
                    let result: i32 = apply_operator(a, b, op);
                    stack_push(&calc->eval_stack, result);
                } else {
                    break;
                }
            }
            
            stack_push(&operator_stack, token.operator as i32);
        } else if (token.type == TOKEN_LPAREN) {
            stack_push(&operator_stack, '(' as i32);
        } else if (token.type == TOKEN_RPAREN) {
            // Evaluar hasta encontrar paréntesis izquierdo
            let found_lparen: bool = false;
            
            while (!stack_is_empty(&operator_stack)) {
                let op: i32 = stack_pop(&operator_stack);
                
                if (op == '(' as i32) {
                    found_lparen = true;
                    break;
                }
                
                if (stack_size(&calc->eval_stack) < 2) {
                    calc->error = true;
                    calc->error_code = ERROR_STACK_UNDERFLOW;
                    return 0;
                }
                
                let b: i32 = stack_pop(&calc->eval_stack);
                let a: i32 = stack_pop(&calc->eval_stack);
                let result: i32 = apply_operator(a, b, op as char);
                stack_push(&calc->eval_stack, result);
            }
            
            if (!found_lparen) {
                calc->error = true;
                calc->error_code = ERROR_MISMATCHED_PARENS;
                return 0;
            }
        }
        
        i = i + 1;
    }
    
    // Aplicar operadores restantes
    while (!stack_is_empty(&operator_stack)) {
        let op: char = stack_pop(&operator_stack) as char;
        
        if (op == '(' || op == ')') {
            calc->error = true;
            calc->error_code = ERROR_MISMATCHED_PARENS;
            return 0;
        }
        
        if (stack_size(&calc->eval_stack) < 2) {
            calc->error = true;
            calc->error_code = ERROR_STACK_UNDERFLOW;
            return 0;
        }
        
        let b: i32 = stack_pop(&calc->eval_stack);
        let a: i32 = stack_pop(&calc->eval_stack);
        let result: i32 = apply_operator(a, b, op);
        stack_push(&calc->eval_stack, result);
    }
    
    // Debe quedar exactamente un valor en la stack
    if (stack_size(&calc->eval_stack) != 1) {
        calc->error = true;
        calc->error_code = ERROR_STACK_UNDERFLOW;
        return 0;
    }
    
    return stack_pop(&calc->eval_stack);
}

// === FUNCIÓN PRINCIPAL DE LA CALCULADORA ===

@wcet(1500)
fn calculate(expression: [20]char) -> i32 {
    let calc: Calculator;
    
    // Tokenizar la expresión
    if (!tokenize_expression(&calc, expression)) {
        return -1000 - calc.error_code;  // Error de tokenización
    }
    
    // Evaluar la expresión
    let result: i32 = evaluate_expression(&calc);
    
    if (calc.error) {
        return -2000 - calc.error_code;  // Error de evaluación
    }
    
    return result;
}

// === CASOS DE PRUEBA ===

fn test_basic_arithmetic() -> i32 {
    let expr1: [20]char = "2+3";
    let result1: i32 = calculate(expr1);  // Debe ser 5
    
    let expr2: [20]char = "5*4";
    let result2: i32 = calculate(expr2);  // Debe ser 20
    
    let expr3: [20]char = "8-3";
    let result3: i32 = calculate(expr3);  // Debe ser 5
    
    let expr4: [20]char = "6/2";
    let result4: i32 = calculate(expr4);  // Debe ser 3
    
    return result1 + result2 + result3 + result4;  // 5+20+5+3 = 33
}

fn test_precedence() -> i32 {
    let expr1: [20]char = "2+3*4";
    let result1: i32 = calculate(expr1);  // Debe ser 14 (no 20)
    
    let expr2: [20]char = "8/2+1";
    let result2: i32 = calculate(expr2);  // Debe ser 5 (no 2)
    
    return result1 + result2;  // 14 + 5 = 19
}

fn test_parentheses() -> i32 {
    let expr1: [20]char = "(2+3)*4";
    let result1: i32 = calculate(expr1);  // Debe ser 20
    
    let expr2: [20]char = "2*(3+4)";
    let result2: i32 = calculate(expr2);  // Debe ser 14
    
    return result1 + result2;  // 20 + 14 = 34
}

fn main() -> i32 {
    let basic: i32 = test_basic_arithmetic();      // 33
    let precedence: i32 = test_precedence();       // 19
    let parens: i32 = test_parentheses();          // 34
    
    let total: i32 = basic + precedence + parens;  // 33+19+34 = 86
    
    // Verificar que todos los tests pasaron
    if (basic == 33 && precedence == 19 && parens == 34) {
        return total;  // 86
    } else {
        return -1;  // Error en tests
    }
}

/*
PROYECTO: CALCULADORA EN TEMPO

Este proyecto demuestra:

1. ESTRUCTURAS DE DATOS:
   - Stack para evaluación de expresiones
   - Tokens para representar elementos
   - Calculator state management

2. ALGORITMOS:
   - Tokenización de expresiones
   - Shunting-yard algorithm (simplificado)
   - Stack-based expression evaluation
   - Operator precedence handling

3. MANEJO DE ERRORES:
   - Error codes específicos
   - Graceful error handling
   - Input validation

4. CARACTERÍSTICAS DE TEMPO:
   - @wcet annotations para timing guarantees
   - Memory safety (no buffer overflows)
   - Deterministic execution
   - Type safety

5. CASOS DE PRUEBA:
   - Aritmética básica: +, -, *, /
   - Precedencia de operadores
   - Paréntesis para agrupación
   - Error handling

LIMITACIONES ACTUALES:
- Solo números de un dígito
- Solo operadores básicos
- No hay números negativos
- No hay funciones matemáticas

EXTENSIONES POSIBLES:
- Números multi-dígito
- Números decimales
- Funciones (sin, cos, sqrt)
- Variables
- Expresiones más complejas

COMPILAR Y EJECUTAR:
tempo run calculator.tempo
echo $?  # Debe mostrar 86

COMPLEJIDAD:
- Tokenización: O(n) donde n = longitud expresión
- Evaluación: O(n) para expresión válida
- Memoria: O(n) para stack y tokens
- WCET: Bounded por anotaciones

Este ejemplo muestra cómo Tempo puede manejar
proyectos reales con guarantías de tiempo y memoria.
*/